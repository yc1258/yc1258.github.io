{
  "name": "Yc1258.GitHub.io",
  "tagline": "blog",
  "body": "# C++\r\n1.\t构造函数从基类开始，析构函数从子类开始。构造函数不能为虚函数是因为对象还没有创建，无法形成虚表，且对象类型不确定。\r\n2.\t类的析构函数会自动调用非静态成员变量的析构函数。\r\n3.\t!!x不一定等于x。例如x = 10, !x = 0, !!x = 1。\r\n4.\tarr[i]恒等于*(arr+i)，&arr[i]恒等于arr + i。将指针（数组名）+1实际是加上了一个与指针指向的类型的长度相等的值。\r\n5.\t数组名本身就是指针，再加&就是双指针，即二维数组。&a+1，即数组整体加一行。\r\n6.\t数组名做参数其实是传递地址，如果要保证原始数据就加const；结构体名作参数还是按值传递。\r\n7.\tconst int *p = &a，p是常量指针，不能通过修改*p来修改a，但a本身可以改；int * const p = &a，p是指针常量，只能指向a。全看const和*的位置关系。\r\n8.\t指针形参，引用形参尽量使用const，因为const可以处理const和非const的情况，否则只能处理非const。\r\n9.\t要保证成员函数不修改调用它的对象，应int fun() const声明。\r\n10.\t避免返回指向对象内部的handles（包括指针、引用和迭代器），因为这有可能破坏封装性或最终指向一个已被销毁的值。如A & func() const返回了一个指向内部private数据的指针，外部就可以通过返回值访问private数据。\r\n11.\tC风格字符串是以空字符结尾的一个char数组，所以不用传数组长度给形参，直接用循环判断字符是否为空字符即可——while(*str)。\r\n12.\t三种静态变量：都默认初始化为0，都存储在静态变量区。函数外声明的非static变量，链接性为外部，所有文件中都可访问；函数外声明的static变量（或const变量），链接性为内部，这个文件可以访问；函数内声明的static变量，无链接性，只有函数内部可访问，但一开始就一直存在在静态区。全局共享数据应用外部链接性，单个文件的函数共享数据应用内部链接性，而且可以避免名称与其他文件冲突。\r\n13.\t类的静态成员变量，所有对象都共用这一个变量。不能在类声明中初始化静态成员变量，除非是const整型或const枚举，因为声明不真正分配内存，只能在类的实现文件中通过作用域操作符：：初始化该静态变量。\r\n14.\t类的静态成员函数只能访问静态变量；通过类调用，不能通过对象调用；只在该源文件中可以访问。\r\n15.\t外部变量和内部变量同名时，会隐藏外部变量，除非使用extern引用声明或::符号。引用声明中不能初始化。其他文件要使用内部链接性的静态变量时，也需要extern。\r\n16.\t对象做函数参数时，应尽量使用引用，避免按值传递生成拷贝（即调用拷贝构造函数）降低效率。如果不能改变对象，加const。\r\n17.\t对象作为函数返回值时，尽量使用引用。除非对象是在函数中被创建的，那么返回时对象已不存在，所以只能直接返回对象，生成拷贝。\r\n18.\t除了内置类型、STL迭代器和函数对象可以按值传递，其他情况下尽量使用const引用传递。\r\n19.\t拷贝构造函数定义时参数应为对象的引用，否则会在传入时调用拷贝构造函数以陷入死循环。\r\n20.\tcopying函数（包括拷贝构造和赋值）应确保复制对象内所有变量以及所有父类成分，通过在子类copying函数中调用父类copying函数。否则该对象的父类成分会被默认构造函数初始化。\r\n21.\t如果拷贝构造函数和赋值函数中的代码很多相似，也不能在一个中调用另一个。应该将相同的部分放在第三个函数中，这个函数往往是private的成员函数并且命名为init。\r\n22.\t当函数按值传递对象进函数，按值从函数返回对象，或用一个对象去初始化另一个对象时，会调用拷贝构造函数，默认实行浅拷贝。如果类中有静态成员或有new出来的指针成员，应显式定义一个拷贝构造函数，其中应分配足够空间来存储复制的数据（而不是指向现有内存），进行深拷贝，并更新静态成员变量的值。\r\n23.\tA a ; A b = a;是用a初始化b，等价于A b = A(a)，调用拷贝构造函数；A a ,b ; b = a;调用赋值构造函数。\r\n24.\tstrlen() 返回字符串长度，但不包括空字符。\r\n25.\tchar *a,b ; a = b ;只是复制地址，没有创建字符串副本，要复制字符串要strcpy()。\r\n26.\t调用构造函数时，对象在函数代码前被创建，成员变量被分配内存，所以在构造函数中无法再给const变量和引用变量赋值。这时需要初始化成员列表。\r\n27.\t写在构造函数体内的其实是赋值操作，是在default构造函数为变量赋初始值之后立刻再赋新值。而初始化成员列表的做法是将值作为各变量构造函数的实参，是真正的初始化。\r\n28.\tA *a ; A *b ; a = b ;是a指向b指向的对象，之后b改变不影响a。\r\n29.\t类自动生成的方法除了四种函数，还有地址操作符。它将返回this指针的值。\r\n30.\t如果不想要类自动生成某方法，可以将相应方法声明为private并且只声明不实现。\r\n31.\t类A的成员变量有char *a，则构造函数A (char *b)中应为其分配内存a = new char[strlen(b)+1]并使用strcpy赋值strcpy(a,b)。\r\n32.\tchar *a和char a[]不是同一类型。指针指向的是字符串常量，放在静态区（可以理解为static），只能读不能写，a本身是一个指针，可以指向别的字符串；数组本身在栈里，可读可写，a本身是一个数组名，即字符串的首地址，是一个指针常量，所以不能指向别的地址。\r\n33.\tchar *a = “abc”，打印*a为a，a为abc，&a为一串地址。\r\n34.\t虚表实质是一个虚函数指针构成的指针数组，按照虚函数的声明顺序排列，子类如果新的虚函数，地址加在数组最后；虚指针在对象的起始位置。对象调用虚函数的时候，根据虚指针指向的类中的函数地址去调用，从而实现多态。\r\n35.\t普通方法是通过早绑定，在编译期间就通过指针类型确定了地址；虚函数是晚绑定，在运行期间才通过对象类型的虚表确定地址。多态必须通过指向对象的指针或引用调用虚方法，这样才能使用为对象类型定义的方法，而不是用为指针或引用类型定义的方法。\r\n36.\t基类引用可以指向从基类派生出的任何类型，所以一个基类对象的参数也可以传派生类对象。\r\n37.\t派生类不能直接访问基类私有成员，只能通过基类成员函数。\r\n38.\t如果基类显式定义了构造函数，在派生类构造函数中应使用初始化成员列表调用Derived::Derived(T a,T b):base (a,b) ;否则创建派生类对象时只调用基类默认构造函数。\r\n39.\tdynamic_cast在运行期间检查是否合理，将使用一个指向派生类对象的基类指针来生成（返回）一个派生类的指针，且基类中必须有虚函数，如果不满足关系返回0。B *b = dynamic_cast<B*>(a) ; const_cast将一个const值转化为非const；static_cast在编译期间进行检查，可以上下转换有父子关系的类型（若无继承关系则报错，子类转换为父类是安全的，反之不安全需用dynamic_cast）以及强制转换数值类型，如static_cast<int>(a)。\r\n40.\t防止内存泄露的最好办法是，在构造函数中或得资源并在析构函数中释放。即RAII class。常用的是shared_ptr和auto_ptr。\r\n41.\t在能使用shared_ptr的时候，尽量使用shared_ptr。shared_ptr只要你不发生循环引用，那么这个东西可以安全地互相传递、随便你放在什么容器里面添加删除、你想放哪里就放在哪里，再也不用考虑这个对象的生命周期问题了。\r\n42.\tRAII class应该提供一个“获取其内部所管理的资源”的方法，以使调用者能够访问原始资源。一般而言显式定义一个get方法。\r\n43.\t智能指针是类似指针功能的模板类，所以可以通过析构函数释放指向的内存。只能用于new，不能用于new[]。\r\n44.\t如果多个智能指针指向同一对象，在析构时会发生问题。所以若通过拷贝构造函数或赋值操作符复制智能指针，被赋值的指针将变为null，而新指针获得资源。\r\n45.\t不要在有构造函数和析构函数的对象上使用memset（或者memcpy）。如果一个对象需要memset，那么在该对象的构造函数里面memset自己。如果你需要memset一个对象数组，那也在该对象的构造函数里面memset自己。如果你需要memset一个没有构造函数的复杂对象，那么请为他添加一个构造函数，除非那是别人的API提供的东西。\r\n46.\t编译器会在子类A的析构函数中创建一个对~A()的调用动作，所以即使实现为空也要提供一份定义。\r\n47.\t如果析构函数中可能抛出异常，析构函数应该捕捉并不处理或结束程序。如果需要对该异常做出反应，应提供一个其他普通函数来进行而非在析构函数中。\r\n48.\t生成子类对象时，在调用父类构造函数刚开始，所有运行期类型信息就都会把该对象视为父类类型，例如虚函数，dynamic_cast，因为子类的内容还没开始构造。析构函数也同理，在子类析构函数开始时，子类成员变量就都已成为未知值。所以，在构造函数和析构函数运行期间，不能调用虚函数。\r\n49.\t赋值操作符应return *this，即返回指向操作符左侧实参的引用。这是为了可以实现连续赋值。即a=b=c。\r\n50.\t不同编译单元中的非局部静态对象的初始化顺序是无法确定的，这时可以使用一个单例模式，将这些对象分别封装在自己的专属函数中（对象在函数内声明为static），然后函数返回一个对象的引用。这样对象就在函数调用的时候才会被初始化。\r\n51.\t越少函数能访问private变量则封装性越好，所以将一个对象作为参数传进一个非成员非友元函数来处理的封装性要比直接写成员函数好。\r\n52.\t被explicit修饰的构造函数不能进行隐式类型转换，对不同类型的参数只能显式调用构造对象。如A a = 12; 就不行，必须用A a(12)。\r\n53.\t有class参与的隐式类型转换，是通过类似将其他类型作为构造函数参数传入以创建一个临时的class对象完成的。但是如果发生隐式类型转换的函数是一个成员函数，其调用者，即地位相当于this指针的那个对象无法进行隐式类型转换。比如定义了重载运算符函数*，a * 2就类似A b(2);a * b; 是合理的，但2 * a 就不行。所以如果有隐式类型转换，应该用非成员函数。\r\n54.\ttemplate<> void func (A & , A &) {}为该模板的显式具体化，指对于A类型不适用于一般的模板定义，必须重新定义一个方法；template void func <A> (A &,A &)为该模板的显式实例化，只有声明没有定义，编译器根据模板定义与该声明生成一个专门的只接受A类型的func函数，否则在实际调用中才会根据参数类型隐式实例化该函数。\r\n55.\t名称空间中的变量可以用using xx::a声明，也可以用using namespace xx编译指令全部导入。如果在函数中导入名称空间与局部变量重名，则名称空间的变量被隐藏，和全局变量一样。不过仍可以通过域操作符访问。\r\n56.\t尽量使用域解析操作符或using声明代替using编译指令。\r\n57.\t最好不要在头文件中使用using编译指令，因为包含头文件的顺序可能影响程序行为。如果非要使用，应放在所有#include之后。\r\n58.\t匿名名称空间，因为无名所以无法在其他地方使用，所以类似于链接性为内部的静态变量。\r\n59.\t如果一个变量没有立刻被需要，尽量延后定义的时间。对于变量在循环中的情况，如果赋值成本比构造和析构成本低，应该在循环外先定义变量，然后在循环内赋值。\r\n60.\t一个对象可能拥有一个以上的地址。当用一个基类指针指向派生类对象时（隐式转型），两个指针的值可能并不相同，会有一个偏移量。这在多重继承几乎必定发生，单一继承也有可能出现。\r\n61.\t要在子类中调用父类的成员函数，如果使用static_cast<Base> (*this).func()；实际上是在派生类对象的Base成分的副本上调用了Base::func。如果func修改了对象内容，改动的是副本，实际当前对象并没有被修改。这种情况应该直接调用Base::func() 。\r\n62.\tint **a = &b，a表示一个指向b的指针的地址，本质也是一个指针。\r\n63.\t指针传参时，当p作为形参传递时，只是传递p的地址给q，即p，q是两个指向相同地址的两个不同指针。在my_malloc函数中只是为q分配内存区域，并不是为p分配。P永远获得不到内存，而函数调用一直造成内存泄露。(pic)\r\n64.\t空类的大小为1，带有虚函数的空类大小为4。\r\n65.\t引用、const类型声明时，必须同时初始化。\r\n66.\tmain函数中可以不写return，编译器会隐式返回0。\r\n67.\tdelete一个指针后，指针所指向的内存被释放，但是指针仍指向该内存。再通过该指针操作该区域会很危险。所以delete指针后，应该将其置为0。\r\n68.\tmalloc/free是标准库函数，不能用于对象（因为无法调用构造函数和析构函数）；new/delete是运算符，可以满足动态创建对象的需求。\r\n69.\tnew操作返回的是一个指向该类对象的指针。A *p = new A()。\r\n70.\t限制一个类对象只能在栈中实例化，可以通过重载new运算符；只能在堆中实例化，类似单例模式。\r\n71.\t对对象进行操作符重载时，可以使用成员函数A operator*(A &a)，也可以使用友元非成员函数重载friend A operator*(A &a，A&b)。\r\n72.\t实现动态数组的方法，可以通过new一个数量为变量的数组（如果不用new无法编译通过，因为在编译期间就要确定长度），或使用vector。\r\n73.\tvector的size表示实际元素数量，对应resize来修改大小；capacity是指当前分配的容量大小，这部分除了实际元素外都是空的，当元素数量超过容量时会重新分配内存，对应reserve方法来修改大小。\r\n74.\tC++11的lambda表达式，格式为[](int a){}；中括号表示函数对象的参数，不能省略，空表示没有，=表示局部变量按值传递，&表示局部变量按引用传递，[=，a，&b]表示a按值传递(无&符号的变量)，b按引用传递（有&符号的变量），其他都按值传递（=或&无变量）。\r\n75.\t正向迭代器继承了输入、输出迭代器，并且可以++操作；双向迭继承了正向，并且可以--；随机继承了双向，并可以对指针进行运算，以及对数据排序。\r\n76.\t使用vector<T> :: iterator 声明的迭代器，即vector本身的默认迭代器是随机迭代器；list的迭代器是双向迭代器，所以不能进行非成员的sort调用，只能调用成员函数sort。\r\n77.\tset，map都是关联容器，且键都是唯一的，set只包含键，map是键值对；加multi则键可以不唯一。这四个容器内部结构是红黑树，元素会在插入时自动排好序，查找使用二分查找。\r\n78.\t#define TOSTR(X) #X  TOSTR(xujie)代表：\"xujie\"；#define ADDPRE(X) add##X  ADDPRE(xujie)代表：addxujie ；#define TOCHAR(X) #@x  TOCHAR(x)代表：'x'。#代表：将宏参数转换成字符串，##代表：将##左右的标识符连接成一个，但不是字符串，#@代表：将宏参数转换成单个字符。\r\n79.\t保护继承：基类公有和保护成员在派生类中变为保护成员；私有继承：基类公有和保护成员在派生类中变为私有成员；\r\n80.\t浮点类型与0比较，需要a<0.000001 && a>-0.0000001；指针需要与NULL比较。\r\n81.\tvector使用erase删除元素后，会返回当前位置下一个位置的迭代器；map不会跳到下一个位置！所以需要iter = a.erase(iter++)。\r\n82.\tdouble a =1/3；a = 0。因为1和3都是int。\r\n\r\n# 网络编程\r\n1.\tOSI模型由下至上分别是物理层、数据链路层、网络层（IP）、传输层（TCP/UDP）、会话层表示层应用层（统称为应用层）。\r\n2.\tTCP连接流程：服务器端1）创建套接字create；2）绑定端口号bind；3）监听连接listen；4）接受连接请求accept，并返回新的套接字；5）用新返回的套接字recv/send；6）关闭套接字；客户端1）创建套接字create; 2）发起建立连接请求connect; 3）发送/接收数据send/recv；4）关闭套接字。\r\n3.\tTCP重发机制：1.滑动窗口机制，确立收发的边界，能让发送方知道已经发送了多少（已确认）、尚未确认的字节数、尚待发送的字节数；让接收方知道（已经确认收到的字节数）。2.选择重传，用于对传输出错的序列进行重传。\r\n4.\tTCP的缓冲区在对方确认接收后清零，UDP发出后就清零。\r\n5.\t调用bind()可以指定一个ip地址，或一个端口号，或两者都指定，或两者都不指定。如果一个套接字未绑定端口，调用connect或listen时内核会为其选择一个临时端口。这对client来说是正常的，但server一般要用众所周知的固定端口。\r\n6.\t当socket()创建一个套接字时，默认为一个用于connect的套接字。服务器需要用listen将其转化为监听套接字，即从CLOSED状态转化为LISTEN状态。\r\n7.\t调用fork()会使父子进程共享的描述符（listenfd，connfd）引用计数+1，之后close()只能使其-1。\r\n8.\t基于线程的服务器中，多个线程都共享同一个进程的描述符，它的引用计数一直为1，所以只需关闭一个已连接描述符，就足以释放所有与这个描述符相关的存储资源了。\r\n9.\t网络协议使用大端字节序，可以通过字节排序函数ntohs等转换。\r\n10.\t字节操纵函数bzero把目标字符串指定字节置为0，通常用来把一个套接字地址结构初始化为0。\r\n11.\t结尾为_in的函数，in表示internet而不是input。\r\n12.\tTCP三次握手而不是两次握手的原因是，如果第一步阻塞了很久才到达，会建立不必要的连接，浪费服务器资源；四次挥手而不是三次挥手的原因是，第二步返回后，只是表示客户端没有数据传输了但服务器有可能还有数据向客户端传输，完毕之后才进行第三步。\r\n13.\tHTTP步骤：1，浏览器发送请求，Header包括方法（GET仅请求资源，POST附带用户数据）、路径、域名等；2，服务器返回，Header包括响应代码（如404资源不存在）、响应类型（Content-Type表示资源类型，网页、图片或视频等），Body为资源（如html代码、图片二进制数据等）。\r\n\r\n# 操作系统\r\n1.\tUnix系统中调用fork创建一个与调用进程相同的副本，之后通过调用execve或类似的系统调用修改子进程的存储映像并运行新程序。之所以需要两步是为了在两步之间允许子进程处理文件描述符。而在Windows中调用CreateProcess就可以完成这两步创建进程。\r\n2.\t进程可以通过调用exit（windows下ExitProcess）主动退出，或操作系统通过调用kill（windows下TerminateProcess）被动结束。\r\n3.\t进程（线程）的三种状态：运行、就绪、阻塞。\r\n4.\t中断是指CPU切换进程，原子操作即整个操作期间屏蔽中断。这对于信号量等相关操作非常重要。\r\n5.\t线程根据操作者可以分为用户级线程和内核线程。\r\n6.\t进程之间具有不同地址空间，而线程拥有相同地址空间和共享数据，可以实现准并行运行。比如在同一个文档上操作，只能是一个进程，但可以有多个线程同时负责交互、排版、定时备份等。\r\n7.\t进程共享物理内存、磁盘等，独享地址空间、数据等；线程共享地址空间、全局变量等，独享程序计数器、寄存器、堆栈等。\r\n8.\t进程间通信，通过信号量、共享内存（需要通过信号量来实现同步）、管程（pipe）、消息队列等进行通信以改变进程状态。\r\n9.\t管程中任意时刻只有一个活跃进程，由编译器负责检查。\r\n10.\t用户级某个线程如果阻塞，内核会将整个进程阻塞；内核级线程阻塞，则内核会调度其他线程。\r\n11.\t与互斥量相关的线程调用：pthread_mutex_init创建互斥量，pthread_mutex_destroy销毁，pthread_mutex_lock加锁或阻塞，pthread_mutex_unlock解锁。\r\n12.\t条件变量调用：除了init和destroy，pthread_cond_wait阻塞以等待一个信号，pthread_cond_singal发信号来唤醒。一般与互斥锁（见11）一起使用，用于让一个线程锁住一个互斥量，然后阻塞等待另一个线程发一个信号来唤醒。如果不使用条件变量，线程就要不断尝试获得互斥锁并检测条件是否达成。\r\n13.\t信号量存在内存中，条件变量不存在内存中，如果将信号量传递给一个没有线程在等待的条件变量，会造成信号丢失。\r\n14.\t银行家算法通过拒绝可能引起不安全状态的请求来避免死锁。安全状态指存在一个事件序列保证所有进程都能完成。\r\n15.\t两个互相轮询等待的进程产生活锁，因为没有进程被阻塞，但也无法进展。\r\n16.\t死锁的检测即有向图是否存在环。\r\n17.\t异步IO需要通过一个消息循环实现，主线程不断读取、处理消息，IO操作的返回会在消息队列中等待处理。这在GUI中很常见，如键盘鼠标等输入的回调，实际都在消息队列中等待处理。\r\n18.\t条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待\"条件变量的条件成立\"而挂起；另一个线程使\"条件成立\"（给出条件成立信号）。\r\n19.\t阻塞、非阻塞、多路复用都属于同步IO。非阻塞IO是指发出IO请求后不阻塞立即返回，但进程/线程还需要自己一直查看数据是否可以读写，这其中还是会产生阻塞。而异步IO不主动读写数据，而由操作系统内核的消息触发机制去完成。\r\n20.\tIO模型：事件来临时，select的轮询机制是系统会去遍历所有fd是否数据已准备好，当fd很多的时候，效率当然就直线下降了，而且最多只能查找1024个；epoll采用基于事件的通知方式，一旦某个fd数据就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，而不需要不断的去轮询查找就绪的描述符，这就是epoll高效最本质的原因。\r\n21.\tEpoll包括三个接口：epoll_create创建句柄，epoll_ctl注册事件，epoll_wait等待事件触发。两种触发模式：LT（水平触发，默认）只要fd中有数据可读，每次epoll_wait就都会返回它的事件；ET（边缘触发）只提示一次，直到fd中有新数据流入。\r\n\r\n# CSAPP\r\n1.\t字节对齐是对每个成员的起始地址的要求，比如double必须起始地址是8的倍数，一个内部最长成员为int的结构体起始地址是4的倍数。\r\n2.\t(pic) sizeof(AA)为8，BB为12，CC为16。如果CC占用8字节内存，同样的AA，BB都是8字节的内存，这样的话，如果把一个指向AA实例的指针赋给一个指向CC实例的指针，那么就会把AA中的8字节直接盖到CC的8字节上，结果CC实例中的b，c都被赋上了不是我们想要的值，这很可能会导致你的程序出问题。父类的data member会在子类的实例中有完整的一份，这样在有继承关系的类之间进行类型转换，就只用简单的修改指针的指向。\r\n3.\t预防字符串缓冲区攻击的方法，栈地址随机化（每次程序开始都先分配一段空地址以改变后续地址），栈破坏检测（通过判断哨兵值是否被程序改变），限制可执行代码区域（只有保存着编译器产生的代码的那部分存储器是可执行的）。\r\n4.\tCode Motion（代码移动）优化，对于循环内的函数调用（包括循环条件），最好放在循环外完成赋值给一个变量，用变量去循环。这样只需调用一次，否则每次循环都会调用一次。\r\n5.\t消除不必要存储器引用优化，对于循环内下次读的是这次写的指针引用值的情况，可以用一个临时变量存储每次的值，在循环结束后再一次写入对应指针引用内。(pic)\r\n6.\t循环展开是编译器层面的优化，通过将多次迭代合并为一次，减少总共的迭代次数。\r\n7.\t访问速度CPU寄存器 > cache > 主存 > 磁盘。\r\n8.\t程序局部性指倾向于引用更近的数据。对同一局部变量反复引用时时间局部性最好，对同一数组进行步长为1（一个数组元素大小）的引用时空间局部性最好。（练习题6.9）这样保证了cache的高命中率，使程序运行更快。\r\n9.\t一开始cache为空时，CPU在cache中的查询必然不命中，这是无法避免的。之后cache加载该数据块，然后该数据块中的数据都会命中，直到该数据块因cache空间不足被替换。\r\n10.\tfork()调用一次会返回两次，一次在父进程中返回子进程pid，一次在子进程中返回0。\r\n11.\twaitpid()挂起一个进程，直到它或它的一个子进程终止，然后返回这个终止进程的pid，并将其从系统中回收。\r\n12.\t使用malloc请求堆空间时，如果在存储器上没有找到合适的空闲块，垃圾收集器将查找并释放垃圾块，返回时molloc再次请求，如果仍然没有合适的空闲块，将向操作系统请求额外的存储器。\r\n13.\tJava等高级语言对如何创建和使用指针有严格控制，能够回收所有垃圾；C系语言不会用类型信息来标记存储器位置，因此像int等标量可以伪装成指针，收集器无法判断它实际是int而不是指针，所以保守地标记为可达，尽管实际上可能是不可达的。\r\n14.\t未初始化的全局变量会被隐式初始化为0，但是堆存储器不会这样。所以molloc出来的变量要进行显式初始化。\r\n15.\t*a- - 这个语句因为*和- - 的优先级相同且右结合，实际会对指针进行操作。正确的应为(*a)- - 。\r\n\r\n# Python\r\n1.\tList声明使用[]；Tuple声明使用()，如果只有一个元素，需要使用逗号，如T = (1,)。\r\n2.\t函数参数带*的为可变参数，可以传入多个值或传入一个带*的list或tuple。\r\n3.\t函数参数带**的为关键字参数，可以传入多个键值对或传入一个带**的dict。\r\n4.\t函数参数有一个单独*的为命名关键字参数分隔符，其后的参数必须传入对应名称的键值对。\r\n5.\t索引-1可以取最后一个元素。\r\n6.\t对list,tuple或字符串进行切片操作L[x:y:z]，x表示起始索引，y表示结束索引，0可以省略，z可选表示间隔默认1。比如L = list(range(100))是0-99的列表   L[:10:2]得到[0,2,4,6,8]。\r\n7.\t列表生成式可以很简洁地生成列表，如 \r\n8.\t生成器可以在每次迭代中动态生成列表中每一项的值。可以通过用()代替[]声明列表生成式产生，也可以通过yield将函数定义为生成式。生成式函数每次在yield处返回，再运行时从上次返回的yield处继续执行。\r\n9.\tmap，reduce，filter都接受一个函数和一个序列，map对序列依次操作，reduce对序列累加操作，filter剔除不满足条件的元素。\r\n10.\t装饰器在不改变原函数定义的前提下增加原函数功能，即在函数func1声明前加@func2，调用func1实际是调用func2(func1)。\r\n11.\t通过functools.partial(func，…)将原函数的某些参数固定并返回新函数。\r\n12.\t成员变量名以两个下划线开头__的为私有变量。以双下划线开头并结尾的，是特殊变量。\r\n13.\t双下划线__init__方法是构造函数，第一个参数是self。\r\n14.\ttype()返回对象类型，isinstance()返回是否是对象本身或父类，dir()返回对象所有属性。\r\n15.\t因为是动态语言所以可以在实例创建后，给对象单独绑定变量或方法，这种绑定和类的绑定不同，只有该对象实例才拥有这些变量或方法。\r\n16.\t类的__slots__属性限制了对象所能拥有的所有属性。不在这个tuple内的属性无法被创建绑定。\r\n17.\t类的特殊方法（定制类）包括：__str__()可定制调用print方法打印对象时的输出；__iter__()返回迭代对象以使得实例对象可以用于for…in循环；__getitem__()中实现对象可以使用下标方式取值，如list、dict；__getattr__()中处理调用类中原本不存在的变量时的情况；__call__()中实现直接调用对象实例本身时的情况。\r\n18.\t装饰器@property生成getter方法，@xxx.setter生成xxx属性的setter方法。\r\n19.\t使用with语句可以在调用open()打开文件后进行IO操作时不需要手动调用close()。\r\n\r\n# 数据结构\r\n1.\t数组查找数据的复杂度为O(1)，插入删除为O(n)，适合存取元素而不频繁插入删除元素，且知道表的长度。单链表查找和插入删除都为O(n)，但是一次插入多个时只有第一次是O(n)后面都是O(1)，所以越频繁插入删除操作越有优势，且不需考虑表的长度问题\r\n2.\t判断链表中是否有环，即判断尾指针是否指向某个表中节点。可以两个指针每次一个走一步一个走两步，循环下去如果发生相遇即有环。\r\n3.\t双链表实际是一种空间换时间的结构。\r\n4.\t树的存储结构可以整个用数组存储。如需父节点信息，每个节点结构可以带一个整数表示父节点的下标；如子节点个数不固定，可以在节点结构中添加一个指向第一个子节点的指针，组成一个链表，第一个子节点结构包括自己的下标和指向第二个子节点位置的指针，直到指针为空表示子节点已表示完。\r\n5.\t二叉树的存储使用链式存储，每个节点有两个指针指向左右子节点。\r\n6.\t二叉树知道前序中序可确定后序，知道中序后序可确定前序，但不知道中序无法确定。\r\n7.\t线索二叉树是为了避免子节点指针为空的浪费，在节点结构中加入两个布尔值，表示左右指针是指向子节点，还是指向中序遍历前驱和后继节点。\r\n8.\t赫夫曼树又称最优二叉树，是节点权值和该节点到根节点路径长度乘积相加最短的二叉树。构造赫夫曼树只需从权值最低的点开始依次向上构造即可。\r\n9.\t无向图用邻接矩阵存储，有向图用邻接链表存储。深度优先遍历用递归回溯思想，通过栈实现；广度优先遍历通过队列实现。\r\n10.\t最小生成树是找出图中连接所有顶点的最小权值的边。普利姆算法是从顶点出发，逐步找各个顶点上最小权值的边；克鲁斯卡尔算法是直接去找最小权值的边。\r\n11.\t单链表逆向输出的递归算法。 (pic)\r\n12.\t数据量大时适合用快速、归并或堆排序，大部分已排好序时适合用插入或冒泡排序。\r\n13.\t对二叉排序树中序遍历得到从小到大排列的数据。\r\n14.\t哈希函数表示的是key与value的存放地址之间的关系。\r\n15.\t创建哈希函数时，如果已知关键字的分布情况均匀，可以用直接寻址法；如果不知道，数字位数比较大的适合用数字分析法（如key为手机号，取后4位作为地址），或折叠相加法；数字位数比较小的适合用平方取中法；关键字长度不等的适合用随机数法；最常用的是取余数法。\r\n16.\t处理哈希表冲突时，如果冲突不多，用公共溢出区法比较合适。另外还有开放定址法，再哈希法，链地址法。\r\n17.\t堆是树状结构，可用最小（大）堆求海量数据的前N大（小）个数据。\r\n18.\t求海量数据中第N大的数、不重复的数等，可以通过将数据分治（大数据无法在内存中存放的就通过文件形式），缩小范围，直到数据规模小到可以在内存中进行。\r\n\r\n# Objective-C/IOS\r\n1.\t只能实例化对象指针，不能直接A a。\r\n2.\tOC中的类可以有私有变量，没有私有方法。\r\n3.\tid是通用对象指针类型，实例初始化方法应返回id类型。可以有多个自定义的初始化方法，但是只能有一个指定初始化方法，该方法应对所有变量进行初始化，其中super必须调用父类的指定初始化方法，并最终返回self。\r\n4.\t方法调用在OC中是以接收消息的形式，[receiver message]，其中消息接受者是且只能是对象指针，消息本身是方法名。消息最终调用了什么函数，是在运行时动态绑定的。编译器将[receiver message]转换为objc_msgSend(receiver，selector，arg1，…)，其中selector是方法的SEL值。通过这个派发函数的receiver对象的isa指针去寻找对应类对象，在类对象中找SEL值匹配的方法，实现调用。\r\n5.\t如果是[super message]，则调用对象还是receiver，只是方法要从父类中开始寻找。\r\n6.\tget方法直接命名为变量名，不加get。调用时可以使用a . xxx调用，如a.xxx = 10，即set xxx变量的值为10，等价于setXxx。\r\n7.\tset方法中不能使用self . xxx，这样会产生递归调用set方法。\r\n8.\t成员有对象类型的类，需要重载dealloc方法，类似析构函数。self.xxx = nil这种方式等价于self.xxx release并且self .xxx = nil。\r\n9.\t可以使用属性声明直接生成get、set方法，包括成员变量本身也可生成而不用自己写。通过@property声明每个变量，再通过@synthesize合成方法。括号中的属性有三组：atomic（多线程锁，默认）和nonatomic，readonly（不生成set方法）和readwrite（默认），retain（用于对象类型，引用传递，实际对引用计数进行了处理）、copy（值传递对象）和assign（默认，用于值类型，实际是直接赋值）。\r\n10.\t如果需要属性和变量不同名，可以在@synthesize中xxx = sss，这样属性名是xxx，变量名是sss，方法中可以用self.xxx引用属性，类外只能用a.xxx访问属性，无法获得变量的名称。\r\n11.\tsuper是编译器指示符，告诉编译器这个消息是从父类传过来，即调用的父类方法，并不是说是父类对象调用了方法。\r\n12.\t方法中创建对象并返回时，应在return中调用autorelease。\r\n13.\t指针调方法时，真正调用方法的是指向的对象，和指针本身无关。如pA = pB后，pA调用的方法就是pB所指对象在调用，和pA原来指向的对象无关。\r\n14.\tOC的多态不一定要基类指针，id类型的通用指针也可以实现多态，在对象类型都一样的情况下，实际上是通过对象本身去实现的。因为所有对象的根类NSObject的第一个实例变量是一个Class类型的结构体指针isa，Class是一个类对象结构体。类其实也是一种对象，称为类对象，在程序运行时一直存在，其中存储了类对象的地址isa、类的大小instance_size、父类superclass、名字name、变量ivars和方法列表methodLists等。类对象调用alloc时，实际是通过malloc类对象中instance_size数量的空间以实例化对象，然后将类对象的地址赋给该对象第一个变量即isa指针。之后在传递消息时，会根据isa的地址找到类对象，在类对象中的methodLists中寻找该方法，如果没有，则根据superclass继续向上寻找。从而实现多态。\r\n15.\tId类型是动态类型，在运行时才能确定对象具体类型。类似A *p = xxx，p是静态类型的，编译期就确定了类型。如果不涉及多态，应使用静态类型。\r\n16.\t在methodLists中寻找方法并不是通过对比字符串，OC在编译时会对同样签名的方法给一个唯一的SEL类型的ID，通过这个ID去寻找方法。即使在不同类中，只要签名相同ID就相同。SEL本身是一个objc_selector结构体的别名。一个方法的SEL类型ID可以通过SEL a = @selector(func) 得到。\r\n17.\tIMP类型是implementation的缩写，实际是一种函数指针类型。通过对象调用methodForSelector传入SEL值，可以获得该方法的指针，从而使用C语言的形式直接调用。这个被指向的方法有两个隐含参数，第一个是self，第二个是SEL，并返回id类型。 (pic)\r\n18.\t由于每次传递消息都需要从isa指针去寻找类对象中的方法进行对比，同一个方法连续使用时影响效率。可以直接先通过获取该方法SEL，通过获取IMP调用。\r\n19.\t动态类型识别的应用：(pic)  \r\n20.\t动态加载 (pic)\r\n21.\t协议即抽象类或接口，@optional是可以实现也可以不实现的，@required（默认）必须实现。协议作为委托时一般都是为了实现异步回调。\r\n22.\tUI事件定义IBAction成员变量和对应属性（记得release），从事件拖动到file’s owner。需要对控件属性改变，则定义输出口，即IBOutlet，将file’s owner拖动到控件。如果是比如导航视图，则不是file’s owner而是当前视图控制器。\r\n23.\t关闭键盘的动作是通过文本控件调用 resignFirstResponder 即放弃第一响应者来实现的。点关闭按钮的事件可以直接在文本控件的事件中找，点屏幕关闭需要把View的类改为UIControl。\r\n24.\tUIAlertView调用show后需要立刻release。\r\n25.\tNSTimer的单位是秒，对象调用invalidate停止计时器事件。\r\n26.\t如果在屏幕旋转时不同视图之间需要有较大差别，则需要作不同的页面，然后每种视图页面实例化一份控件，重写屏幕即将旋转的方法，进行更换。横竖屏切换时需要更换屏幕尺寸，注意状态栏的高度。\r\n27.\tWebView是通过WebKit框架实现的，支持html5不支持flash。\r\n\r\n# Nginx\r\n1.\treload调用后会启动一个新的nginx进程并向原先的master进程发信号，master会加载配置文件，之后启动新的worker进程以接收新的请求，并向老worker进程发信号，老worker进程收到信号后不再接收新请求，会在完成当前进程中任务后退出。\r\n2.\tworker的个数应该和cpu核数相等，更多的worker数，只会导致进程来竞争cpu资源了，从而带来不必要的上下文切换。\r\n3.\t在操作系统中，通过ulimit -n，我们可以得到一个进程所能够打开的fd的最大数，即nofile，因为每个socket连接会占用掉一个fd，所以这也会限制我们进程的最大连接数，当然也会直接影响到我们程序所能支持的最大并发数，当fd用完后，再创建socket时，就会失败。nginx通过设置worker_connectons来设置每个进程支持的最大连接数。如果该值大于nofile，那么实际的最大连接数是nofile，nginx会有警告。nginx在实现时，是通过一个连接池来管理的，每个worker进程都有一个独立的连接池，连接池的大小是worker_connections。这里的连接池里面保存的其实不是真实的连接，它只是一个worker_connections大小的一个ngx_connection_t结构的数组。并且，nginx会通过一个链表free_connections来保存所有的空闲ngx_connection_t，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}