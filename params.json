{
  "name": "Yc1258.GitHub.io",
  "tagline": "my blog for some reading notes",
  "body": "# C++\r\n1.\t构造函数从基类开始，析构函数从子类开始。构造函数不能为虚函数是因为对象还没有创建，无法形成虚表，且对象类型不确定。\r\n2.\t类的析构函数会自动调用非静态成员变量的析构函数。\r\n3.\t!!x不一定等于x。例如x = 10, !x = 0, !!x = 1。\r\n4.\tarr[i]恒等于*(arr+i)，&arr[i]恒等于arr + i。将指针（数组名）+1实际是加上了一个与指针指向的类型的长度相等的值。\r\n5.\t数组名本身就是指针，再加&就是双指针，即二维数组。&a+1，即数组整体加一行。\r\n6.\t数组名做参数其实是传递地址，如果要保证原始数据就加const；结构体名作参数还是按值传递。\r\n7.\tconst int *p = &a，p是常量指针，不能通过修改*p来修改a，但a本身可以改；int * const p = &a，p是指针常量，只能指向a。全看const和*的位置关系。\r\n8.\t指针形参，引用形参尽量使用const，因为const可以处理const和非const的情况，否则只能处理非const。\r\n9.\t要保证成员函数不修改调用它的对象，应int fun() const声明。\r\n10.\t避免返回指向对象内部的handles（包括指针、引用和迭代器），因为这有可能破坏封装性或最终指向一个已被销毁的值。如A & func() const返回了一个指向内部private数据的指针，外部就可以通过返回值访问private数据。\r\n11.\tC风格字符串是以空字符结尾的一个char数组，所以不用传数组长度给形参，直接用循环判断字符是否为空字符即可——while(*str)。\r\n12.\t三种静态变量：都默认初始化为0，都存储在静态变量区。函数外声明的非static变量，链接性为外部，所有文件中都可访问；函数外声明的static变量（或const变量），链接性为内部，这个文件可以访问；函数内声明的static变量，无链接性，只有函数内部可访问，但一开始就一直存在在静态区。全局共享数据应用外部链接性，单个文件的函数共享数据应用内部链接性，而且可以避免名称与其他文件冲突。\r\n13.\t类的静态成员变量，所有对象都共用这一个变量。不能在类声明中初始化静态成员变量，除非是const整型或const枚举，因为声明不真正分配内存，只能在类的实现文件中通过作用域操作符：：初始化该静态变量。\r\n14.\t类的静态成员函数只能访问静态变量；通过类调用，不能通过对象调用；只在该源文件中可以访问。\r\n15.\t外部变量和内部变量同名时，会隐藏外部变量，除非使用extern引用声明或::符号。引用声明中不能初始化。其他文件要使用内部链接性的静态变量时，也需要extern。\r\n16.\t对象做函数参数时，应尽量使用引用，避免按值传递生成拷贝（即调用拷贝构造函数）降低效率。如果不能改变对象，加const。\r\n17.\t对象作为函数返回值时，尽量使用引用。除非对象是在函数中被创建的，那么返回时对象已不存在，所以只能直接返回对象，生成拷贝。\r\n18.\t除了内置类型、STL迭代器和函数对象可以按值传递，其他情况下尽量使用const引用传递。\r\n19.\t拷贝构造函数定义时参数应为对象的引用，否则会在传入时调用拷贝构造函数以陷入死循环。\r\n20.\tcopying函数（包括拷贝构造和赋值）应确保复制对象内所有变量以及所有父类成分，通过在子类copying函数中调用父类copying函数。否则该对象的父类成分会被默认构造函数初始化。\r\n21.\t如果拷贝构造函数和赋值函数中的代码很多相似，也不能在一个中调用另一个。应该将相同的部分放在第三个函数中，这个函数往往是private的成员函数并且命名为init。\r\n22.\t当函数按值传递对象进函数，按值从函数返回对象，或用一个对象去初始化另一个对象时，会调用拷贝构造函数，默认实行浅拷贝。如果类中有静态成员或有new出来的指针成员，应显式定义一个拷贝构造函数，其中应分配足够空间来存储复制的数据（而不是指向现有内存），进行深拷贝，并更新静态成员变量的值。\r\n23.\tA a ; A b = a;是用a初始化b，等价于A b = A(a)，调用拷贝构造函数；A a ,b ; b = a;调用赋值构造函数。\r\n24.\tstrlen() 返回字符串长度，但不包括空字符。\r\n25.\tchar *a,b ; a = b ;只是复制地址，没有创建字符串副本，要复制字符串要strcpy()。\r\n26.\t调用构造函数时，对象在函数代码前被创建，成员变量被分配内存，所以在构造函数中无法再给const变量和引用变量赋值。这时需要初始化成员列表。\r\n27.\t写在构造函数体内的其实是赋值操作，是在default构造函数为变量赋初始值之后立刻再赋新值。而初始化成员列表的做法是将值作为各变量构造函数的实参，是真正的初始化。\r\n28.\tA *a ; A *b ; a = b ;是a指向b指向的对象，之后b改变不影响a。\r\n29.\t类自动生成的方法除了四种函数，还有地址操作符。它将返回this指针的值。\r\n30.\t如果不想要类自动生成某方法，可以将相应方法声明为private并且只声明不实现。\r\n31.\t类A的成员变量有char *a，则构造函数A (char *b)中应为其分配内存a = new char[strlen(b)+1]并使用strcpy赋值strcpy(a,b)。\r\n32.\tchar *a和char a[]不是同一类型。指针指向的是字符串常量，放在静态区（可以理解为static），只能读不能写，a本身是一个指针，可以指向别的字符串；数组本身在栈里，可读可写，a本身是一个数组名，即字符串的首地址，是一个指针常量，所以不能指向别的地址。\r\n33.\tchar *a = “abc”，打印*a为a，a为abc，&a为一串地址。\r\n34.\t虚表实质是一个虚函数指针构成的指针数组，按照虚函数的声明顺序排列，子类如果新的虚函数，地址加在数组最后；虚指针在对象的起始位置。对象调用虚函数的时候，根据虚指针指向的类中的函数地址去调用，从而实现多态。\r\n35.\t普通方法是通过早绑定，在编译期间就通过指针类型确定了地址；虚函数是晚绑定，在运行期间才通过对象类型的虚表确定地址。多态必须通过指向对象的指针或引用调用虚方法，这样才能使用为对象类型定义的方法，而不是用为指针或引用类型定义的方法。\r\n36.\t基类引用可以指向从基类派生出的任何类型，所以一个基类对象的参数也可以传派生类对象。\r\n37.\t派生类不能直接访问基类私有成员，只能通过基类成员函数。\r\n38.\t如果基类显式定义了构造函数，在派生类构造函数中应使用初始化成员列表调用Derived::Derived(T a,T b):base (a,b) ;否则创建派生类对象时只调用基类默认构造函数。\r\n39.\tdynamic_cast在运行期间检查是否合理，将使用一个指向派生类对象的基类指针来生成（返回）一个派生类的指针，且基类中必须有虚函数，如果不满足关系返回0。B *b = dynamic_cast<B*>(a) ; const_cast将一个const值转化为非const；static_cast在编译期间进行检查，可以上下转换有父子关系的类型（若无继承关系则报错，子类转换为父类是安全的，反之不安全需用dynamic_cast）以及强制转换数值类型，如static_cast<int>(a)。\r\n40.\t防止内存泄露的最好办法是，在构造函数中或得资源并在析构函数中释放。即RAII class。常用的是shared_ptr和auto_ptr。\r\n41.\t在能使用shared_ptr的时候，尽量使用shared_ptr。shared_ptr只要你不发生循环引用，那么这个东西可以安全地互相传递、随便你放在什么容器里面添加删除、你想放哪里就放在哪里，再也不用考虑这个对象的生命周期问题了。\r\n42.\tRAII class应该提供一个“获取其内部所管理的资源”的方法，以使调用者能够访问原始资源。一般而言显式定义一个get方法。\r\n43.\t智能指针是类似指针功能的模板类，所以可以通过析构函数释放指向的内存。只能用于new，不能用于new[]。\r\n44.\t如果多个智能指针指向同一对象，在析构时会发生问题。所以若通过拷贝构造函数或赋值操作符复制智能指针，被赋值的指针将变为null，而新指针获得资源。\r\n45.\t不要在有构造函数和析构函数的对象上使用memset（或者memcpy）。如果一个对象需要memset，那么在该对象的构造函数里面memset自己。如果你需要memset一个对象数组，那也在该对象的构造函数里面memset自己。如果你需要memset一个没有构造函数的复杂对象，那么请为他添加一个构造函数，除非那是别人的API提供的东西。\r\n46.\t编译器会在子类A的析构函数中创建一个对~A()的调用动作，所以即使实现为空也要提供一份定义。\r\n47.\t如果析构函数中可能抛出异常，析构函数应该捕捉并不处理或结束程序。如果需要对该异常做出反应，应提供一个其他普通函数来进行而非在析构函数中。\r\n48.\t生成子类对象时，在调用父类构造函数刚开始，所有运行期类型信息就都会把该对象视为父类类型，例如虚函数，dynamic_cast，因为子类的内容还没开始构造。析构函数也同理，在子类析构函数开始时，子类成员变量就都已成为未知值。所以，在构造函数和析构函数运行期间，不能调用虚函数。\r\n49.\t赋值操作符应return *this，即返回指向操作符左侧实参的引用。这是为了可以实现连续赋值。即a=b=c。\r\n50.\t不同编译单元中的非局部静态对象的初始化顺序是无法确定的，这时可以使用一个单例模式，将这些对象分别封装在自己的专属函数中（对象在函数内声明为static），然后函数返回一个对象的引用。这样对象就在函数调用的时候才会被初始化。\r\n51.\t越少函数能访问private变量则封装性越好，所以将一个对象作为参数传进一个非成员非友元函数来处理的封装性要比直接写成员函数好。\r\n52.\t被explicit修饰的构造函数不能进行隐式类型转换，对不同类型的参数只能显式调用构造对象。如A a = 12; 就不行，必须用A a(12)。\r\n53.\t有class参与的隐式类型转换，是通过类似将其他类型作为构造函数参数传入以创建一个临时的class对象完成的。但是如果发生隐式类型转换的函数是一个成员函数，其调用者，即地位相当于this指针的那个对象无法进行隐式类型转换。比如定义了重载运算符函数*，a * 2就类似A b(2);a * b; 是合理的，但2 * a 就不行。所以如果有隐式类型转换，应该用非成员函数。\r\n54.\ttemplate<> void func (A & , A &) {}为该模板的显式具体化，指对于A类型不适用于一般的模板定义，必须重新定义一个方法；template void func <A> (A &,A &)为该模板的显式实例化，只有声明没有定义，编译器根据模板定义与该声明生成一个专门的只接受A类型的func函数，否则在实际调用中才会根据参数类型隐式实例化该函数。\r\n55.\t名称空间中的变量可以用using xx::a声明，也可以用using namespace xx编译指令全部导入。如果在函数中导入名称空间与局部变量重名，则名称空间的变量被隐藏，和全局变量一样。不过仍可以通过域操作符访问。\r\n56.\t尽量使用域解析操作符或using声明代替using编译指令。\r\n57.\t最好不要在头文件中使用using编译指令，因为包含头文件的顺序可能影响程序行为。如果非要使用，应放在所有#include之后。\r\n58.\t匿名名称空间，因为无名所以无法在其他地方使用，所以类似于链接性为内部的静态变量。\r\n59.\t如果一个变量没有立刻被需要，尽量延后定义的时间。对于变量在循环中的情况，如果赋值成本比构造和析构成本低，应该在循环外先定义变量，然后在循环内赋值。\r\n60.\t一个对象可能拥有一个以上的地址。当用一个基类指针指向派生类对象时（隐式转型），两个指针的值可能并不相同，会有一个偏移量。这在多重继承几乎必定发生，单一继承也有可能出现。\r\n61.\t要在子类中调用父类的成员函数，如果使用static_cast<Base> (*this).func()；实际上是在派生类对象的Base成分的副本上调用了Base::func。如果func修改了对象内容，改动的是副本，实际当前对象并没有被修改。这种情况应该直接调用Base::func() 。\r\n62.\tint **a = &b，a表示一个指向b的指针的地址，本质也是一个指针。\r\n63.\t指针传参时，当p作为形参传递时，只是传递p的地址给q，即p，q是两个指向相同地址的两个不同指针。在my_malloc函数中只是为q分配内存区域，并不是为p分配。P永远获得不到内存，而函数调用一直造成内存泄露。(pic)\r\n64.\t空类的大小为1，带有虚函数的空类大小为4。\r\n65.\t引用、const类型声明时，必须同时初始化。\r\n66.\tmain函数中可以不写return，编译器会隐式返回0。\r\n67.\tdelete一个指针后，指针所指向的内存被释放，但是指针仍指向该内存。再通过该指针操作该区域会很危险。所以delete指针后，应该将其置为0。\r\n68.\tmalloc/free是标准库函数，不能用于对象（因为无法调用构造函数和析构函数）；new/delete是运算符，可以满足动态创建对象的需求。\r\n69.\tnew操作返回的是一个指向该类对象的指针。A *p = new A()。\r\n70.\t限制一个类对象只能在栈中实例化，可以通过重载new运算符；只能在堆中实例化，类似单例模式。\r\n71.\t对对象进行操作符重载时，可以使用成员函数A operator*(A &a)，也可以使用友元非成员函数重载friend A operator*(A &a，A&b)。\r\n72.\t实现动态数组的方法，可以通过new一个数量为变量的数组（如果不用new无法编译通过，因为在编译期间就要确定长度），或使用vector。\r\n73.\tvector的size表示实际元素数量，对应resize来修改大小；capacity是指当前分配的容量大小，这部分除了实际元素外都是空的，当元素数量超过容量时会重新分配内存，对应reserve方法来修改大小。\r\n74.\tC++11的lambda表达式，格式为[](int a){}；中括号表示函数对象的参数，不能省略，空表示没有，=表示局部变量按值传递，&表示局部变量按引用传递，[=，a，&b]表示a按值传递(无&符号的变量)，b按引用传递（有&符号的变量），其他都按值传递（=或&无变量）。\r\n75.\t正向迭代器继承了输入、输出迭代器，并且可以++操作；双向迭继承了正向，并且可以--；随机继承了双向，并可以对指针进行运算，以及对数据排序。\r\n76.\t使用vector<T> :: iterator 声明的迭代器，即vector本身的默认迭代器是随机迭代器；list的迭代器是双向迭代器，所以不能进行非成员的sort调用，只能调用成员函数sort。\r\n77.\tset，map都是关联容器，且键都是唯一的，set只包含键，map是键值对；加multi则键可以不唯一。这四个容器内部结构是红黑树，元素会在插入时自动排好序，查找使用二分查找。\r\n78.\t#define TOSTR(X) #X  TOSTR(xujie)代表：\"xujie\"；#define ADDPRE(X) add##X  ADDPRE(xujie)代表：addxujie ；#define TOCHAR(X) #@x  TOCHAR(x)代表：'x'。#代表：将宏参数转换成字符串，##代表：将##左右的标识符连接成一个，但不是字符串，#@代表：将宏参数转换成单个字符。\r\n79.\t保护继承：基类公有和保护成员在派生类中变为保护成员；私有继承：基类公有和保护成员在派生类中变为私有成员；\r\n80.\t浮点类型与0比较，需要a<0.000001 && a>-0.0000001；指针需要与NULL比较。\r\n81.\tvector使用erase删除元素后，会返回当前位置下一个位置的迭代器；map不会跳到下一个位置！所以需要iter = a.erase(iter++)。\r\n82.\tdouble a =1/3；a = 0。因为1和3都是int。\r\n\r\n# 网络编程\r\n1.\tOSI模型由下至上分别是物理层、数据链路层、网络层（IP）、传输层（TCP/UDP）、会话层表示层应用层（统称为应用层）。\r\n2.\tTCP连接流程：服务器端1）创建套接字create；2）绑定端口号bind；3）监听连接listen；4）接受连接请求accept，并返回新的套接字；5）用新返回的套接字recv/send；6）关闭套接字；客户端1）创建套接字create; 2）发起建立连接请求connect; 3）发送/接收数据send/recv；4）关闭套接字。\r\n3.\tTCP重发机制：1.滑动窗口机制，确立收发的边界，能让发送方知道已经发送了多少（已确认）、尚未确认的字节数、尚待发送的字节数；让接收方知道（已经确认收到的字节数）。2.选择重传，用于对传输出错的序列进行重传。\r\n4.\tTCP的缓冲区在对方确认接收后清零，UDP发出后就清零。\r\n5.\t调用bind()可以指定一个ip地址，或一个端口号，或两者都指定，或两者都不指定。如果一个套接字未绑定端口，调用connect或listen时内核会为其选择一个临时端口。这对client来说是正常的，但server一般要用众所周知的固定端口。\r\n6.\t当socket()创建一个套接字时，默认为一个用于connect的套接字。服务器需要用listen将其转化为监听套接字，即从CLOSED状态转化为LISTEN状态。\r\n7.\t调用fork()会使父子进程共享的描述符（listenfd，connfd）引用计数+1，之后close()只能使其-1。\r\n8.\t基于线程的服务器中，多个线程都共享同一个进程的描述符，它的引用计数一直为1，所以只需关闭一个已连接描述符，就足以释放所有与这个描述符相关的存储资源了。\r\n9.\t网络协议使用大端字节序，可以通过字节排序函数ntohs等转换。\r\n10.\t字节操纵函数bzero把目标字符串指定字节置为0，通常用来把一个套接字地址结构初始化为0。\r\n11.\t结尾为_in的函数，in表示internet而不是input。\r\n12.\tTCP三次握手而不是两次握手的原因是，如果第一步阻塞了很久才到达，会建立不必要的连接，浪费服务器资源；四次挥手而不是三次挥手的原因是，第二步返回后，只是表示客户端没有数据传输了但服务器有可能还有数据向客户端传输，完毕之后才进行第三步。\r\n13.\tHTTP步骤：1，浏览器发送请求，Header包括方法（GET仅请求资源，POST附带用户数据）、路径、域名等；2，服务器返回，Header包括响应代码（如404资源不存在）、响应类型（Content-Type表示资源类型，网页、图片或视频等），Body为资源（如html代码、图片二进制数据等）。\r\n\r\n# MUDUO网络库/多线程\r\n1.\t常用单线程服务器编程模型为non-blocking IO + IO multiplexing，即Reactor模式。基本结构是一个事件循环，以事件驱动和回调实现业务。\r\n2.\t推荐的多线程服务器编程模式为one event loop（用IO multiplexing，non-blocking IO和定时器） per thread + thread pool（用来做计算，可以是blocking queue实现的任务队列或生产者消费者队列）。\r\n3.\t线程安全问题主要由全局变量和静态变量引起。如果线程中这两种变量都只有读，没有写，一般是安全的，否则要考虑同步。\r\n4.\t进程间通信推荐使用TCP sockets。使用netstat –anp定位故障的方法：打印Recv-Q和Send-Q应接近0，如果R不变或增加，可能本地服务器死锁或阻塞；如果S不变或增加，可能对方服务器故障、掉线等。\r\n5.\t两种时候必须使用单线程：程序可能会fork()，一般只有“看门狗进程”；限制程序的CPU占用率。\r\n6.\t多线程服务器中的线程分3类：IO线程，主循环是IO multiplexing，阻塞在select/poll等系统调用上；计算线程，主循环是blocking queue，阻塞在条件变量上，一般在线程池中；第三方库线程，比如log，db等。\r\n7.\t一个程序的线程数目与负载无关，最好是不大于CPU数目。最好在程序初始化阶段创建全部工作线程，运行期间不再创建或销毁，而是使用thread pool和event loop将任务分配到已有线程。\r\n8.\t谨慎使用fork：RAII在fork()时可能不会正常工作，因为会析构两次；多线程的父进程fork()后子进程只有一个线程，唯一安全的做法是fork后立刻exec其他程序，彻底隔断与父进程的联系。\r\n9.\tDouble buffering技术：维护两个buffer，A负责接受数据，B负责将数据写入，A填满了之后交换两个buffer，将数据一次写入。这样可以将多次需要操作的buffer合并为一个大的buffer一次操作，相当于批处理，减少了写入操作的开销。\r\n10.\tTCP长链接分包方法：固定消息长度；使用特殊字符作为消息边界（如HTTP的headers用\\r\\n为字段分隔符）；每条消息头部加一个长度字段；利用消息格式（如XML的标签配对）。\r\n11.\t现实中non-blocking几乎总是和IO multiplexing一起用，因为non-blocking用轮询太浪费CPU，而且IO multiplexing不能和blocking一起用，read()/write()/accept()/connect()都可能阻塞线程，而non-blocking的思想是避免IO阻塞在这些系统调用上，只能阻塞在select/poll/epoll_wait上。\r\n12.\tMUDUO中的IO都是带buffer的，buffer内部是std::vector,这样可以自动增长，而且它的capacity机制减少了内存分配的次数：在resize时如果超过了原本的capacity，capacity会自动翻倍。\r\n13.\t服务器进程一个监听套接字在接受客户端连接调用accept生成已连接套接字后，会fork一个子进程，共享父进程的套接字，ip与port都一样。之后子进程关闭监听套接字，接着读写这个已连接套接字，父进程则关闭这个已连接套接字，继续监听下一个连接。所以一个连接必须通过客户端服务器套接字对总共4个元素才能确定。\r\n14.\t从进程到内核传递套接字地址结构的函数有3个：bind，connect和sendto，这些函数中表示某个套接字地址结构大小的参数为整数类型；从内核到进程传递的有4个：accept，recvfrom，getsockname和getpeername，这些函数中表示某个套接字地址结构大小的参数为引用类型，即值-结果参数——调用时为一个值，告诉内核结构大小，返回时是一个结果，告诉进程内核在该结构中存储了多少信息。\r\n15.\t使用epoll需要3个接口:epoll_create创建一个epoll的fd，epoll_ctl注册监听事件类型，epoll_wait阻塞等待事件触发:LT模式下可以不立即处理，下次调用epoll_wait时会再次响应并通知此事件，ET模式必须立即处理，下次调用epoll_wait时不会再次响应并通知此事件。\r\n16.\tselect和poll的缺点：每次调用都要把所有fd从用户拷贝到内核，并在内核遍历所有fd。epoll通过ctl函数将fd拷贝进内核，所以只拷贝一次，\r\n17.\t如果要访问class的成员，或要知道class的大小以便分配空间，就需要class的完整定义（include头文件）；如果要声明或定义class类型的指针或引用，或声明（不调用）一个以class类型为参数或返回值的函数，则不需要完整定义，只需要前向声明class即可。\r\n18.\t静态库（.a .lib）编译期间会链接到目标文件（.o）中，一起生成可执行文件，运行时不再需要静态库，但每个应用程序都含有一份，浪费空间，而且一旦更新静态库，就要整个重新编译；动态库（.so .dll）程序运行时才链接，所以如果更新，只需更新动态库即可，而且所有应用程序只需共享一份内存中的动态库实例。\r\n19.\t使用function + bind代替继承。用bind将某个成员函数绑到某个对象上时，就得到一个closure，可代替虚函数。而虚函数只需用来替代switch – case以简化代码。\r\n20.\t值语义对象可以拷贝，而且拷贝后所得的对象与原对象无关，值语义对象要么是栈对象，要么是其他对象的成员，所以不用担心生命周期；对象语义的对象禁止拷贝，所以只能用指针或引用来使用，需要小心生命周期带来的问题，最好的办法是使用智能指针将对象语义转化为值语义\r\n21.\t一般不需要自己编写copy construtor或assignment operator，因为只要每个数据成员都具有值语义，编译器自动生成的默认函数就能正常工作。所以，写一个class时让它继承boost::noncopyable几乎总是正确的。\r\n22.\tvector，list，map，set，string，stack，queue都是抽象数据类型（abstract data type，ADT）。ADT都是值语义。\r\n23.\t复杂声明可以使用右左法则分析；对于一串复杂定义，可以用类型代替变量名，并在前面加typedef就可以将其转换为一个简单名称。如typedef void (*fun)(void)即声明一个通用函数指针类型fun。\r\n24.\tchar *a表示指针a指向常量区的一份字符串；char a[]是将常量区的字符串复制到在栈上分配的数组a中，所以可以修改。\r\n\r\n# Unix高级环境编程\r\n1.\t文件IO中的read（int fd，void *buf，size_t nbytes）从fd中读数据，成功返回读到的字节数，已到结尾返回0，出错返回-1。\r\n2.\t文件IO中的write（int fd，const void *buf，size_t nbytes）向fd中写数据，成功返回nbytes数，出错返回-1。\r\n3.\t文件IO中的lseek（l表示long）可以修改文件的偏移量，成功返回新的偏移量。所以lseek（fd,0,SEEK_CUR）可以获得文件的当前偏移量，还可以确定该文件是否可以设置偏移量，如果fd是一个管道、FIFO或socket，则返回-1。\r\n4.\t如果lseek设置的文件偏移量大于文件当前长度，下一次写文件将加长该文件（增大v节点表项中的文件长度），这会在文件中构成一个空洞，其中没有写过的字节都被读为0，但并不分配磁盘空间。\r\n5.\t如果open时指定了O_APPEND选项，则每次写该文件前，会将文件偏移量设置在文件末尾，这是一个原子操作。而之前调用的lseek则会无效。\r\n6.\t内核中打开文件的数据结构如图 如果两个进程打开同一个文件，则v节点表项只有一个，但文件表项有各自的一份，因为不同进程都有自己对该文件的当前偏移量；也有可能多个描述符指向同一文件表项，如调用dup，或fork后的父子进程间。![unp6.png](../images/unp6.png)\r\n7.\t对于复制文件描述符的方法，dup（fd）等价于fcntl（fd,F_DUPFD,0），dup2（fd,fd2）等价于close（fd2）+fcntl（fd,F_DUPFD,fd2）。不过dup2是原子操作。\r\n8.\t使用fcntl修改文件描述符标志或文件状态标志时，必须先取得现有标志值，再修改设置；如果只执行F_SETFD或F_SETFL，会关闭以前设置的标志位。\r\n9.\t文件描述符标志，主要是指close_on_exec，表示子进程调用exec后是否关闭当前fd。\r\n10.\t对目录的读权限，允许获得该目录中所有文件名的列表；对目录的执行权限，可通过该目录进行搜索，寻找一个指定文件名。要在一个目录中创建或删除一个文件，需要对该目录有写权限和执行权限。\r\n11.\tumask修改“文件模式创建屏蔽字”，和chmod是相反的操作。创建新文件时，如果要确保指定的访问权限位激活，必须在运行时修改umask值。比如要确保任何用户都能读文件，则应umask（0）。\r\n12.\t每个文件系统会对自己的i节点编号，每个文件的i节点包含了该文件类型、访问权限、长度等大多数文件信息，只有文件名和i节点编号存放在目录项中。每个i节点都有一个链接计数，值是指向该i节点的目录项数。在不更换文件系统的前提下对文件进行更名操作时，只需构造一个指向目标i节点的新目录项，并解除与旧目录的链接。\r\n13.\t任何一个叶目录的链接计数为2，分别来自命名该目录的目录项，以及该目录中的.项。如果目录中存在子目录，每存在一个都会使父目录的链接计数加1，来自该子目录中的..项。\r\n14.\t要删除一个文件的内容，内核首先检查打开该文件的进程数，如果为0，再检查其链接计数，如果也是0，才会删除。\r\n15.\t指向文件的链接分为硬链接（直接指向i节点，增加目录项，等价于目标文件名。所以要求文件和链接在同一文件系统。只有root用户才能创建指向目录的硬链接）和符号链接（只是关于目标文件的路径的一串文字 ，系统通过它会跳转到对应位置，可以理解为windows的快捷方式）。\r\n16.\t文件的修改时间是内容最后被修改的时间，更改状态时间是i节点最后被修改的时间（更改访问权限、链接数等）。\r\n17.\t标准I/O是围绕流进行的，通过FILE*类型达成对流的引用。标准输入（默认键盘），标准输出和标准出错（默认屏幕）是预定义的三个流，通过stdin、stdout和stderr引用。\r\n18.\t标准I/O提供缓冲，为了减少使用read和write的次数。标准出错不带缓冲（为了尽快显示出错误信息），涉及终端设备的流是行缓冲的（标准输入输出，遇到换行符时执行I/O操作），其余所有流都是全缓冲。\r\n19.\t读写流的三种非格式化I/O：每次一个字符（getc，fgetc，getchar和putc，fputc，putchar），每次一行（fgets和fputs），直接I/O（fread和fwrite）。\r\n20.\t一个进程正常终止时（调用exit或从main返回），所有带未写缓冲数据的标准I/O流都会被 flush，所有打开的标准I/O流都会被关闭。\r\n21.\t每个标准I/O流都有一个与其相关的文件描述符。可以通过fileno函数获得一个流的fd。\r\n22.\t标准I/O的效率不高是因为每次调用一行函数fgets和fputs时，都要进行两次复制：一次在内核和标准I/O缓冲之间，一次在标准I/O缓冲区和用户程序中的行缓冲区之间。\r\n23.\ttime获得time_t类型（秒）的当前时间，gettimeofday获得timeval类型（包括秒和微秒）的当前时间；localtime将日历时间转换为格式化时间存放在tm结构中；asctime（参数tm）和ctime（参数time_t）返回date命令格式的时间字符串。\r\n24.\texit会先进行一些清理操作，再进入内核，包括调用终止处理程序（由atexit注册的一系列函数，在exit时会逐个调用它们）和关闭所有标准I/O流（为所有打开的流调用fclose，这会使所有缓冲数据被flush）。它有一个整型参数，称为终止状态。在main函数中返回整型值与用该值调用exit是等价的，所以在main中调用exit（0）等价于return（0）。\r\n25.\t内核执行程序的唯一方法是调用一个exec函数；进程自愿终止的唯一方法是显式或隐式（通过调用exit）地调用_exit或_Exit；进程也可非自愿地由一个信号使其终止。\r\n26.\t执行一个程序时，内核通过调用exec的进程将命令行参数传递给该程序，参数是一个字符指针数组，在main函数的形参中argc代表参数数量，argv代表参数数组。\r\n27.\t环境表类似命令行参数，也是内核通过调用exec的进程传递到新程序的，也是一个字符指针数组。其中每一项环境变量都是name = value格式。可以通过getenv获取某个name的value，或通过putenv（传入name = value的字符串）或setenv（修改具体name的value）设置name的value。\r\n28.\tC程序的内存分布图，其中包括：栈（连续的内存，固定的大小，从高地址向低地址生长），堆（由一个管理空闲内存的链表每次从低地址开始寻找第一块满足大小要求的空间，所以是不连续的内存，从低地址向高地址生长。如char *a = new char，a在栈上，a指向的变量在堆上），非初始化数据段（存放未初始化或初始化为0的全局变量和静态变量），初始化数据段（存放初始化的全局变量和静态变量），常量段（图中未标出，存放常量数据，只读，对于字符串常量，会去除重复的只保存一份），代码段（存放二进制代码，如函数等）。 ![unp28.png](../images/unp28.png)\r\n29.\tgoto只能在函数内进行跳转，setjmp和longjmp可以实现跨越函数的跳转（抛弃栈帧，局部变量的值会不确定，如果要确保某个值不回滚，可声明为volatile）。\r\n30.\tID为0的是调度进程（系统进程、交换进程），是内核的一部分。ID为1的是init进程，是用户进程但以root权限运行，不会终止，是所有孤儿进程的父进程。\r\n31.\tfork主要两种用法：父进程fork出子进程处理请求，自己继续等待新请求（如网络服务进程）；子进程立即调用exec，分别执行不同程序（如shell）。\r\n32.\tfork调用失败主要的两个原因：系统已经有了太多进程，或该用户的进程总数超过了系统限制。\r\n33.\tfork之后父子进程间相同的fd共享同一个文件表项，所以它们共享文件偏移量。这时一般有两种处理方式：如果操作同一文件，则需要进行同步，即父进程等待子进程完成；如果操作不同文件，则各自关闭不用的fd，互不干扰。\r\n34.\t如果父进程先终止，内核会将其子进程的父进程id设为1，即由init进程领养。\r\n35.\t一个进程终止时，内核会向其父进程发送SIGCHLD信号。如果其父进程调用了wait或waitpid（init会默认调用wait），可以获得其终止状态等信息并正常释放它；如果没有调用，则该进程会变为僵死进程。\r\n36.\twait阻塞等待第一个终止的子进程，waitpid可以指定等待的子进程，且可以设置为不阻塞。\r\n37.\t每个进程组有一个组长，组长进程id等于该进程组id。只要进程组中有进程存活，进程组就存在，与组长进程无关。\r\n38.\t非组长进程调用setsid后，会脱离父进程的进程组，创建一个新session（session是进程组的集合），该进程是新session中唯一进程，且该进程成为一个新进程组的组长。如果是组长进程调用setsid会返回出错，所以通常先fork并终止父进程，此时子进程继承父进程的进程组id且自己拥有新的进程id，两者肯定不相等。\r\n39.\t信号有3种处理方式：忽略，系统默认行为和捕捉。特别地，SIGKILL（杀死进程）和SIGSTOP（挂起进程）不能被忽略或捕捉。\r\n40.\tSIGABRT：调用abort产生；SIGSEGV：segmentation violation，无效内存引用；SIGTERM：由shell命令kill不带参数发送的终止信号，让进程正常退出，与SIGKILL不同的是可以被阻塞和捕获。\r\n41.\tkill函数将信号发送给进程或进程组，参数pid>0，发送给id为pid的进程；pid==0，发送给同进程组的所有进程；pid<0，发送给id为pid绝对值的进程组的所有进程；pid==-1，发送给系统上所有有权限向它们发信号的所有进程。其中都不包括内核进程以及init进程。raise函数将信号发给本进程。\r\n42.\talarm设定计时器，超时后发送SIGALRM，默认终止调用alarm函数的进程。\r\n43.\tpause挂起调用进程直到捕捉到一个信号。\r\n44.\tsleep挂起调用进程，直到超时（返回0），或调用进程捕捉到一个信号并从信号处理程序返回（返回剩余秒数）。\r\n45.\t调用pthread_join（pthread_t thread，void **rval_ptr）的线程将阻塞，直到指定线程退出（调用pthread_exit、正常返回或被pthread_cancel指定取消）。\r\n46.\t线程属性之stackaddr：所有线程共同瓜分进程的栈区，所以如果创建了太多线程导致虚拟地址空间不足，就需要减少线程默认的栈大小；如果线程调用的函数分配了大量局部变量或涉及很深的栈帧，则需要增大默认的栈大小。\r\n47.\t子进程继承了父进程的整个地址空间副本，所以也继承了所有互斥锁、条件变量状态，但子进程中只有一个线程，即父进程中调用fork的线程的副本，如果父进程占有锁，子进程也占有，但子进程并没有占有锁的线程的副本，所以无法处理这些锁。如果子进程不立刻调用exec，就需要清理锁的状态。可以通过pthread_atfork（void （*prepare）（void），void （*parent）（void），void （*child）（void））建立fork的处理程序。其中prepare由父进程在调用fork以后创建子进程前调用，获取父进程的所有锁；parent在创建子进程后fork返回给父进程之前在父进程中调用，对获得的锁解锁；child在创建子进程后fork返回给子进程之前在子进程中调用，对获得的锁解锁。\r\n48.\t接上条，多线程中最好fork后立刻exec。但由于子进程会继承父进程中所有已打开的fd，在fork后exec之前子进程还有可能访问到这些fd。这种情况需要在open这个文件时就设置O_CLOEXEC，相当于让打开文件和设置close_on _exec成为原子操作。\r\n49.\t大多数守护进程都以root特权（uid为0）运行，且父进程是init进程。内核守护进程以无控制终端方式启动（tty为？），用户层守护进程无控制终端可能是调用了setsid。所有用户层守护进程都是其进程组和会话中的唯一进程，所以也是组长进程和会话首进程。\r\n50.\t对于一个给定的fd有两种方法指定为非阻塞I/O：还未打开的文件调用open时指定O_NONBLOCK标志，或对一个已打开的fd调用fcntl并打开O_NONBLOCK标志。\r\n51.\t描述符集fd_set中的每一位表示一个fd，可以进行的操作：声明一个fd_set后，调用FD_ZERO所有位重置为0；调用FD_SET设置指定位；FD_CLR可以清除指定位；从select返回后调用FD_ISSET检测指定位是否设置。\r\n52.\t对于int select（int maxfdp1，fd_set *restrict readfds，fd_set *restrict writefds，fd_set *restrict exceptfds，struct timeval *restrict tvptr），其中maxfdp1为“最大描述符编号+1”；中间三个分别为可读、可写和处于异常条件的描述符集，不关心哪个可以设为空；tvptr表示等待时间，为空表示一直等待。返回-1表示出错，返回0表示没有描述符准备好，返回正数表示已经准备好的描述符数（如果对一个readfds/writefds里的某个fd进行read/write操作不会阻塞，则此fd是准备好的）。\r\n53.\t匿名管道只能在相关进程之间使用，通常，一个管道由一个进程创建int pipe（int filedes[2]），然后该进程fork，父子进程间就可应用该管道。之后例如数据流的方向是父进程到子进程，则父进程关闭管道的读端（fd[0]），子进程关闭写端（fd[1]）。\r\n54.\t读一个写端关闭的管道时，数据读完后read会返回0；写一个读端关闭的管道时，会产生SIGPIPE，如果忽略或从捕捉函数返回，则write返回-1。\r\n55.\t命名管道FIFO是一种文件类型，没有匿名管道只能在相关进程间使用的限制。通过mkfifo创建后，就可以用open打开，此时，如果没有指定O_NONBLOCK，只读open会阻塞直到其他进程用写open打开同一FIFO，只写同理；如果指定O_NONBLOCK，只读立即返回，但如果没有用读open打开的同一FIFO，只写将出错返回-1。\r\n56.\t每个内核中的IPC（消息队列、信号量和共享内存）都有一个外部的key与内部的标识符。通过指定的key创建IPC，key由内核变换为标识符，并返回供进程使用。\r\n57.\t最后一个访问管道的进程终止时，管道就被删除了；最后一个访问FIFO的进程终止时，FIFO中的数据都被删除了，只留下名字直至显式删除它；而消息队列等没有引用计数，在访问进程终止后不会删除数据，直到显式删除，而且果删除了消息队列，仍在使用它的进程再操作它时将会返回错误。\r\n58.\t消息队列中每个消息包含类型、长度和数据段，每次添加到队尾，但可以按类型非先进先出读取。可用来实现客户端服务器之间的双向数据流。\r\n59.\t信号量是一个计数器，进程检测其为正时可使用该资源并将信号量减1，为0时阻塞进程直至信号量大于0。用于多个进程对同一数据对象的访问。\r\n60.\t共享内存允许多个进程共享同一内存区域，因为数据不需要在进程间复制所以速度最快。唯一要注意的是访问的同步，通常使用信号量来实现。\r\n61.\t网络IPC即socket。对于int socket（int domain，int type，int protocol）的三个参数，AF_INET（IPv4因特网域）域中的SOCK_STREAM类型的默认协议是TCP，AF_INET域中的SOCK_DGRAM类型的默认协议是UDP。\r\n62.\tclose只有在最后一个活动引用被关闭时才释放网络端点，而shutdown可以立即停止一个套接字无论引用它的文件描述符有多少；而且，shutdown支持半关闭。\r\n\r\n# Mysql\r\n1.\tDISTINCT放在列名前，修饰整个SELECT的所有列名。\r\n2.\tLIMIT在ORDER BY之后表示显示几个结果。\r\n3.\t列名、表名都可以使用完全限定的，如table.column，或db.table。\r\n4.\tDESC用在ORDER BY的一个列名之后，只对其修饰的一个列名作用，表示降序。\r\n5.\tWHERE的BETWEEN条件包括AND两边的端点值和中间所有值；IN条件只包括所列的值。\r\n6.\t同时有AND和OR的条件中优先处理AND。\r\n7.\tLIKE后跟带有通配符的匹配模式，其中%表示任意个任意字符，_表示一个任意字符。（除非必要，不要把通配符放在搜索模式的开始处，那样是最慢的）。\r\n8.\t使用REGEXP时，如果要匹配特殊字符，需要加两个\\\\进行转义。\r\n9.\tLIKE和REGEXP的区别就是LIKE匹配整个列，REGEXP匹配列的子串。\r\n10.\t可以在SELECT中使用Concat将结果连接为一个串。\r\n11.\tAS可以将列名经过处理的结果值设置别名供客户引用\r\n12.\t常用函数包括文本处理函数如Left()返回串最左边的字符，RTrim()去掉串右边的空格；日期函数如Now()；数值函数如Abs()等。\r\n13.\t聚集函数包括AVG()，COUNT()，SUM()，MAX()和MIN()。\r\n14.\tGROUP BY按列名分组，这会使SELECT中的操作变成对每个组的数据进行。过滤组使用HAVING，和WHERE过滤行的用法一致。\r\n15.\tCREATE TABLE时，可以指定PRIMARY KEY，还可以对列指定NULL或NOT NULL（如果插入NULL会报错），AUTO_INCREMENT（每增加一行自动给值加1），DEFAULT（指定默认值）。\r\n16.\tALTER TABLE更改表的结构。\r\n17.\tCREATE TRIGGER创建触发器，可以BEFORE或AFTER某命令（INSERT，DELETE，UPDATE）时执行特定命令。在INSERT/DELETE时，可引用一个NEW/OLD表代表被插入/删除的行，UPDATE两个表都有。\r\n18.\tCREATE PROCEDURE创建存储过程，即多条SQL的集合，批处理。使用CALL执行。存储过程比一条一条执行其中的语句要快。\r\n19.\tSHOW PROCESSLIST显示所有活动进程，KILL终结特定进程。\r\n20.\t除非真正需要每一列，否则不要用SELECT*。\r\n21.\tSELECT中有一系列复杂的OR时，应使用多条SELECT和UNION。\r\n22.\t同一条SELECT，可以试试联结、子查询等方法，比较性能。\r\n\r\n# HTTP\r\n1.\tURL中;后的参数param以键值对形式出现，提供访问资源的附加信息。\r\n2.\tURL中？后的查询语句query都以键值对形式出现，并以&分隔。\r\n3.\tURL中#后的片段frag指定显示资源的一个片段，这只由客户端使用，服务器只会处理整个对象。\r\n4.\t每个TCP段都有一个序列号和数据完整性校验和，每个段的接收者都会发送一个很小的确认报文给发送者。延迟确认算法，就是在特定窗口时间内将确认分组放到缓冲区，如果有同方向的数据则捎带发送，如果没有超时后才单独发送。而这种算法会造成HTTP的延时，可以调整或禁止。\r\n5.\tTCP的慢启动：TCP刚建立时会限制连接速度，在数据成功传输后会逐渐提高。用于防止因特网的突然过载和拥塞。\r\n6.\t如果一个TCP分组中只包含了少量数据，网络性能就会下降。Nagle算法：将要发送的TCP数据阻塞直到绑定成一个最大TCP分组，再一次发送。这种算法也会造成HTTP延时，如果要禁用，应手动保证每个TCP分组会写入大量数据。\r\n7.\tTIME_WAIT是保证在2MSL内不会创建相同IP和端口的连接。如果能够分配给客户端的端口号不足，就会产生TIME_WAIT端口耗尽问题。\r\n8.\tHTTP的Connection首部中有一列用逗号分隔的字段，其中有一系列首部字段名，keep-alive（1.0）或close（1.1）以及其他描述性的非标准选项。将带有Connection的报文转发出去时，会删除Connection首部以及Connection中列出的所有首部。\r\n9.\t需要同时加载多个资源时，HTTP可以进行并行连接，但这也会受带宽和内存影响，所以一般浏览器仅同时支持4个并行连接。\r\n10.\t持续连接可以避免建立TCP和慢启动延时，配合并行连接可以实现高性能。Keep-alive响应首部中有timeout（连接超时时间）和max（最多还要为几个事务保持该连接打开状态）字段。使用持续连接时需要保证content-length的正确。\r\n11.\t持续连接还可以进行管道化，即将请求都放入队列，在前一个请求的响应返回之前后面的就已经可以连续发送了。管道化需要做好HTTP服务器会随时关闭连接而需要重发的准备，且不能发送非幂等的请求（POST，因为重发可能会导致数据错误）。\r\n12.\t要实现连接的正常关闭，应该先关闭输出信道，然后检查输入信道直到对端关闭输出信道，或超时强制关闭连接。\r\n13.\t每个Web服务器都有一个根目录docroot存放资源。Docroot+HTTP请求的资源即该资源在服务器里的实际路径。如果URL是以/~+用户名开始的，则映射为该用户的私有根目录。\r\n14.\t返回的响应不一定是成功的报文，有可能是重定向。重定向由3XX作为返回码，Location响应首部说明地址。一般用于资源被转移，URL规范/增强，或负载均衡的情况。\r\n15.\t代理连接的是多个使用相同协议的应用程序，网关（Gateway，又叫协议转换器）连接的是多个使用不同协议的端点。\r\n16.\t代理可以根据目的用途，部署在任意位置：（1）出口代理，在本地网络的出口，可以提供防火墙保护、限制带宽、过滤不恰当的访问等；（2）入口（访问）代理，放在ISP访问点上，可以存储常用文档的副本，提高用户访问性能；（3）反向代理，在Web服务器之前，充当Web服务器，可以提高安全性、进行缓存提高性能等；（4）网络交换代理，放在因特网对等交换点上，通过缓存提高性能、进行流量监控等。\r\n17.\t靠近客户端的为子代理，反之为父代理。子代理会根据实际请求选择将要连接的父代理，或直接连接服务器。\r\n18.\t客户端对显式设置的代理会发送完整URI，对Web服务器（包括反向代理、拦截代理等）发送部分URI。代理应该能够使用部分URI和虚拟Host首部来确定原始服务器。\r\n19.\t报文中的via首部记录了报文传送过程中经过的所有代理。请求报文TRACE方法可以在报文到达服务器后，封装在响应报文里完整返回，从而通过via首部查看经过的代理信息。\r\n20.\t请求的资源在缓存中读取成功，称为缓存命中，未成功而被转发到原始服务器，称为未命中。缓存通过与服务器通信以检测资源副本是否是最新的，称为再验证。再验证成功的返回码为304（not modified）。\r\n21.\t响应报文中的Data首部表示的是该资源从原始服务器产生的时间。如果这个时间比报文时间早，说明是从缓存读取的。\r\n22.\t隧道用来将非HTTP流量嵌入HTTP报文中传递以穿过只允许Web流量的防火墙。\r\n23.\t爬虫对访问过的地址进行管理的方法：使用搜索树和散列表记录已访问过的URL，保证查找速度；为了减小这些URL存储空间，会使用有损数据结构，比如存在位数组（用一个散列函数将每个URL转换为一个定长数字，这个数字在数组中有个相关的存在位，爬过之后就将其置位）；已访问URL列表保存在硬盘，以防爬虫崩溃。\r\n24.\t由于URL的别名（指定端口、带有转义符、带#标签、IP与对应域名、大小写不敏感等情况），可能造成多个URL指向同一资源，这会影响爬虫效率，需要将其尽可能转化为规范化URL，如默认80端口，转义符都转换为等价字符，删除#标签，其他情况需要对应服务器特定信息。\r\n25.\t爬虫最怕碰到的就是环路，如果没有特定的试探方法，会造成无限循环。（1）以广度优先来访问URL，就算在某站点碰到环路，也会在下次回到环路之前，从其他站点获取到大量的页面；（2）限制一段时间内爬虫从一个Web站点可获取的页面数量；（3）文件系统的符号连接所造成的环路会遵循某种模式，需要特定的匹配检测；（4）使用内容指纹，爬虫获取页面内容中的字节，计算出一个校验和（如使用MD5），如果之前碰到过这个校验和，就拒绝爬行这个页面；（5）人工干预，如黑名单等。\r\n26.\t服务器识别访问用户的方法：（1）承载用户信息的HTTP首部，包括<1>From：用户的E-mail地址，不过一般不会发送以防信息外泄；<2>User-Agent：用户的浏览器信息；<3>Referer：用户来源页面的URL，即用户之前访问过哪个页面；（2）客户端IP地址，这不能从HTTP获取而是从TCP中，不过很容易伪造；（3）用户登录认证，即用户名密码；（4）胖URL，为每个用户生成特定的URL；（5）cookie，是识别用户，实现持久会话的最好方式。\r\n27.\tcookie分两类，会话cookie是临时的，退出浏览器时删除；持久cookie存储在硬盘上，维护周期性访问的站点的配置文件和登录信息。两者唯一区别是过期时间。\r\n28.\t用户第一次访问站点时，服务器通过Set-Cookie的HTTP响应首部给用户贴上一个cookie。浏览器将cookie内容存储在数据库中，当用户再访问同一站点时，这些cookie会在一个请求首部中传回服务器。\r\n\r\n# 操作系统\r\n1.\tUnix系统中调用fork创建一个与调用进程相同的副本，之后通过调用execve或类似的系统调用修改子进程的存储映像并运行新程序。之所以需要两步是为了在两步之间允许子进程处理文件描述符。而在Windows中调用CreateProcess就可以完成这两步创建进程。\r\n2.\t进程可以通过调用exit（windows下ExitProcess）主动退出，或操作系统通过调用kill（windows下TerminateProcess）被动结束。\r\n3.\t进程（线程）的三种状态：运行、就绪、阻塞。\r\n4.\t中断是指CPU切换进程，原子操作即整个操作期间屏蔽中断。这对于信号量等相关操作非常重要。\r\n5.\t线程根据操作者可以分为用户级线程和内核线程。\r\n6.\t进程之间具有不同地址空间，而线程拥有相同地址空间和共享数据，可以实现准并行运行。比如在同一个文档上操作，只能是一个进程，但可以有多个线程同时负责交互、排版、定时备份等。\r\n7.\t进程共享物理内存、磁盘等，独享地址空间、数据等；线程共享地址空间、全局变量等，独享程序计数器、寄存器、堆栈等。\r\n8.\t进程间通信，通过信号量、共享内存（需要通过信号量来实现同步）、管程（pipe）、消息队列等进行通信以改变进程状态。\r\n9.\t管程中任意时刻只有一个活跃进程，由编译器负责检查。\r\n10.\t用户级某个线程如果阻塞，内核会将整个进程阻塞；内核级线程阻塞，则内核会调度其他线程。\r\n11.\t与互斥量相关的线程调用：pthread_mutex_init创建互斥量，pthread_mutex_destroy销毁，pthread_mutex_lock加锁或阻塞，pthread_mutex_unlock解锁。\r\n12.\t条件变量调用：除了init和destroy，pthread_cond_wait阻塞以等待一个信号，pthread_cond_singal发信号来唤醒。一般与互斥锁（见11）一起使用，用于让一个线程锁住一个互斥量，然后阻塞等待另一个线程发一个信号来唤醒。如果不使用条件变量，线程就要不断尝试获得互斥锁并检测条件是否达成。\r\n13.\t信号量存在内存中，条件变量不存在内存中，如果将信号量传递给一个没有线程在等待的条件变量，会造成信号丢失。\r\n14.\t银行家算法通过拒绝可能引起不安全状态的请求来避免死锁。安全状态指存在一个事件序列保证所有进程都能完成。\r\n15.\t两个互相轮询等待的进程产生活锁，因为没有进程被阻塞，但也无法进展。\r\n16.\t死锁的检测即有向图是否存在环。\r\n17.\t异步IO需要通过一个消息循环实现，主线程不断读取、处理消息，IO操作的返回会在消息队列中等待处理。这在GUI中很常见，如键盘鼠标等输入的回调，实际都在消息队列中等待处理。\r\n18.\t条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待\"条件变量的条件成立\"而挂起；另一个线程使\"条件成立\"（给出条件成立信号）。\r\n19.\t阻塞、非阻塞、多路复用都属于同步IO。非阻塞IO是指发出IO请求后不阻塞立即返回，但进程/线程还需要自己一直查看数据是否可以读写，这其中还是会产生阻塞。而异步IO不主动读写数据，而由操作系统内核的消息触发机制去完成。\r\n20.\tIO模型：事件来临时，select的轮询机制是系统会去遍历所有fd是否数据已准备好，当fd很多的时候，效率当然就直线下降了，而且最多只能查找1024个；epoll采用基于事件的通知方式，一旦某个fd数据就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，而不需要不断的去轮询查找就绪的描述符，这就是epoll高效最本质的原因。\r\n21.\tEpoll包括三个接口：epoll_create创建句柄，epoll_ctl注册事件，epoll_wait等待事件触发。两种触发模式：LT（水平触发，默认）只要fd中有数据可读，每次epoll_wait就都会返回它的事件；ET（边缘触发）只提示一次，直到fd中有新数据流入。\r\n\r\n# CSAPP\r\n1.\t字节对齐是对每个成员的起始地址的要求，比如double必须起始地址是8的倍数，一个内部最长成员为int的结构体起始地址是4的倍数。\r\n2.\t(pic) sizeof(AA)为8，BB为12，CC为16。如果CC占用8字节内存，同样的AA，BB都是8字节的内存，这样的话，如果把一个指向AA实例的指针赋给一个指向CC实例的指针，那么就会把AA中的8字节直接盖到CC的8字节上，结果CC实例中的b，c都被赋上了不是我们想要的值，这很可能会导致你的程序出问题。父类的data member会在子类的实例中有完整的一份，这样在有继承关系的类之间进行类型转换，就只用简单的修改指针的指向。\r\n3.\t预防字符串缓冲区攻击的方法，栈地址随机化（每次程序开始都先分配一段空地址以改变后续地址），栈破坏检测（通过判断哨兵值是否被程序改变），限制可执行代码区域（只有保存着编译器产生的代码的那部分存储器是可执行的）。\r\n4.\tCode Motion（代码移动）优化，对于循环内的函数调用（包括循环条件），最好放在循环外完成赋值给一个变量，用变量去循环。这样只需调用一次，否则每次循环都会调用一次。\r\n5.\t消除不必要存储器引用优化，对于循环内下次读的是这次写的指针引用值的情况，可以用一个临时变量存储每次的值，在循环结束后再一次写入对应指针引用内。(pic)\r\n6.\t循环展开是编译器层面的优化，通过将多次迭代合并为一次，减少总共的迭代次数。\r\n7.\t访问速度CPU寄存器 > cache > 主存 > 磁盘。\r\n8.\t程序局部性指倾向于引用更近的数据。对同一局部变量反复引用时时间局部性最好，对同一数组进行步长为1（一个数组元素大小）的引用时空间局部性最好。（练习题6.9）这样保证了cache的高命中率，使程序运行更快。\r\n9.\t一开始cache为空时，CPU在cache中的查询必然不命中，这是无法避免的。之后cache加载该数据块，然后该数据块中的数据都会命中，直到该数据块因cache空间不足被替换。\r\n10.\tfork()调用一次会返回两次，一次在父进程中返回子进程pid，一次在子进程中返回0。\r\n11.\twaitpid()挂起一个进程，直到它或它的一个子进程终止，然后返回这个终止进程的pid，并将其从系统中回收。\r\n12.\t使用malloc请求堆空间时，如果在存储器上没有找到合适的空闲块，垃圾收集器将查找并释放垃圾块，返回时molloc再次请求，如果仍然没有合适的空闲块，将向操作系统请求额外的存储器。\r\n13.\tJava等高级语言对如何创建和使用指针有严格控制，能够回收所有垃圾；C系语言不会用类型信息来标记存储器位置，因此像int等标量可以伪装成指针，收集器无法判断它实际是int而不是指针，所以保守地标记为可达，尽管实际上可能是不可达的。\r\n14.\t未初始化的全局变量会被隐式初始化为0，但是堆存储器不会这样。所以molloc出来的变量要进行显式初始化。\r\n15.\t*a- - 这个语句因为*和- - 的优先级相同且右结合，实际会对指针进行操作。正确的应为(*a)- - 。\r\n\r\n# Python\r\n1.\tList声明使用[]；Tuple声明使用()，如果只有一个元素，需要使用逗号，如T = (1,)。\r\n2.\t函数参数带*的为可变参数，可以传入多个值或传入一个带*的list或tuple。\r\n3.\t函数参数带**的为关键字参数，可以传入多个键值对或传入一个带**的dict。\r\n4.\t函数参数有一个单独*的为命名关键字参数分隔符，其后的参数必须传入对应名称的键值对。\r\n5.\t索引-1可以取最后一个元素。\r\n6.\t对list,tuple或字符串进行切片操作L[x:y:z]，x表示起始索引，y表示结束索引，0可以省略，z可选表示间隔默认1。比如L = list(range(100))是0-99的列表   L[:10:2]得到[0,2,4,6,8]。\r\n7.\t列表生成式可以很简洁地生成列表，如 \r\n8.\t生成器可以在每次迭代中动态生成列表中每一项的值。可以通过用()代替[]声明列表生成式产生，也可以通过yield将函数定义为生成式。生成式函数每次在yield处返回，再运行时从上次返回的yield处继续执行。\r\n9.\tmap，reduce，filter都接受一个函数和一个序列，map对序列依次操作，reduce对序列累加操作，filter剔除不满足条件的元素。\r\n10.\t装饰器在不改变原函数定义的前提下增加原函数功能，即在函数func1声明前加@func2，调用func1实际是调用func2(func1)。\r\n11.\t通过functools.partial(func，…)将原函数的某些参数固定并返回新函数。\r\n12.\t成员变量名以两个下划线开头__的为私有变量。以双下划线开头并结尾的，是特殊变量。\r\n13.\t双下划线__init__方法是构造函数，第一个参数是self。\r\n14.\ttype()返回对象类型，isinstance()返回是否是对象本身或父类，dir()返回对象所有属性。\r\n15.\t因为是动态语言所以可以在实例创建后，给对象单独绑定变量或方法，这种绑定和类的绑定不同，只有该对象实例才拥有这些变量或方法。\r\n16.\t类的__slots__属性限制了对象所能拥有的所有属性。不在这个tuple内的属性无法被创建绑定。\r\n17.\t类的特殊方法（定制类）包括：__str__()可定制调用print方法打印对象时的输出；__iter__()返回迭代对象以使得实例对象可以用于for…in循环；__getitem__()中实现对象可以使用下标方式取值，如list、dict；__getattr__()中处理调用类中原本不存在的变量时的情况；__call__()中实现直接调用对象实例本身时的情况。\r\n18.\t装饰器@property生成getter方法，@xxx.setter生成xxx属性的setter方法。\r\n19.\t使用with语句可以在调用open()打开文件后进行IO操作时不需要手动调用close()。\r\n\r\n# 数据结构\r\n1.\t数组查找数据的复杂度为O(1)，插入删除为O(n)，适合存取元素而不频繁插入删除元素，且知道表的长度。单链表查找和插入删除都为O(n)，但是一次插入多个时只有第一次是O(n)后面都是O(1)，所以越频繁插入删除操作越有优势，且不需考虑表的长度问题\r\n2.\t判断链表中是否有环，即判断尾指针是否指向某个表中节点。可以两个指针每次一个走一步一个走两步，循环下去如果发生相遇即有环。\r\n3.\t双链表实际是一种空间换时间的结构。\r\n4.\t树的存储结构可以整个用数组存储。如需父节点信息，每个节点结构可以带一个整数表示父节点的下标；如子节点个数不固定，可以在节点结构中添加一个指向第一个子节点的指针，组成一个链表，第一个子节点结构包括自己的下标和指向第二个子节点位置的指针，直到指针为空表示子节点已表示完。\r\n5.\t二叉树的存储使用链式存储，每个节点有两个指针指向左右子节点。\r\n6.\t二叉树知道前序中序可确定后序，知道中序后序可确定前序，但不知道中序无法确定。\r\n7.\t线索二叉树是为了避免子节点指针为空的浪费，在节点结构中加入两个布尔值，表示左右指针是指向子节点，还是指向中序遍历前驱和后继节点。\r\n8.\t赫夫曼树又称最优二叉树，是节点权值和该节点到根节点路径长度乘积相加最短的二叉树。构造赫夫曼树只需从权值最低的点开始依次向上构造即可。\r\n9.\t无向图用邻接矩阵存储，有向图用邻接链表存储。深度优先遍历用递归回溯思想，通过栈实现；广度优先遍历通过队列实现。\r\n10.\t最小生成树是找出图中连接所有顶点的最小权值的边。普利姆算法是从顶点出发，逐步找各个顶点上最小权值的边；克鲁斯卡尔算法是直接去找最小权值的边。\r\n11.\t单链表逆向输出的递归算法。 (pic)\r\n12.\t数据量大时适合用快速、归并或堆排序，大部分已排好序时适合用插入或冒泡排序。\r\n13.\t对二叉排序树中序遍历得到从小到大排列的数据。\r\n14.\t哈希函数表示的是key与value的存放地址之间的关系。\r\n15.\t创建哈希函数时，如果已知关键字的分布情况均匀，可以用直接寻址法；如果不知道，数字位数比较大的适合用数字分析法（如key为手机号，取后4位作为地址），或折叠相加法；数字位数比较小的适合用平方取中法；关键字长度不等的适合用随机数法；最常用的是取余数法。\r\n16.\t处理哈希表冲突时，如果冲突不多，用公共溢出区法比较合适。另外还有开放定址法，再哈希法，链地址法。\r\n17.\t堆是树状结构，可用最小（大）堆求海量数据的前N大（小）个数据。\r\n18.\t求海量数据中第N大的数、不重复的数等，可以通过将数据分治（大数据无法在内存中存放的就通过文件形式），缩小范围，直到数据规模小到可以在内存中进行。\r\n\r\n# Objective-C/IOS\r\n1.\t只能实例化对象指针，不能直接A a。\r\n2.\tOC中的类可以有私有变量，没有私有方法。\r\n3.\tid是通用对象指针类型，实例初始化方法应返回id类型。可以有多个自定义的初始化方法，但是只能有一个指定初始化方法，该方法应对所有变量进行初始化，其中super必须调用父类的指定初始化方法，并最终返回self。\r\n4.\t方法调用在OC中是以接收消息的形式，[receiver message]，其中消息接受者是且只能是对象指针，消息本身是方法名。消息最终调用了什么函数，是在运行时动态绑定的。编译器将[receiver message]转换为objc_msgSend(receiver，selector，arg1，…)，其中selector是方法的SEL值。通过这个派发函数的receiver对象的isa指针去寻找对应类对象，在类对象中找SEL值匹配的方法，实现调用。\r\n5.\t如果是[super message]，则调用对象还是receiver，只是方法要从父类中开始寻找。\r\n6.\tget方法直接命名为变量名，不加get。调用时可以使用a . xxx调用，如a.xxx = 10，即set xxx变量的值为10，等价于setXxx。\r\n7.\tset方法中不能使用self . xxx，这样会产生递归调用set方法。\r\n8.\t成员有对象类型的类，需要重载dealloc方法，类似析构函数。self.xxx = nil这种方式等价于self.xxx release并且self .xxx = nil。\r\n9.\t可以使用属性声明直接生成get、set方法，包括成员变量本身也可生成而不用自己写。通过@property声明每个变量，再通过@synthesize合成方法。括号中的属性有三组：atomic（多线程锁，默认）和nonatomic，readonly（不生成set方法）和readwrite（默认），retain（用于对象类型，引用传递，实际对引用计数进行了处理）、copy（值传递对象）和assign（默认，用于值类型，实际是直接赋值）。\r\n10.\t如果需要属性和变量不同名，可以在@synthesize中xxx = sss，这样属性名是xxx，变量名是sss，方法中可以用self.xxx引用属性，类外只能用a.xxx访问属性，无法获得变量的名称。\r\n11.\tsuper是编译器指示符，告诉编译器这个消息是从父类传过来，即调用的父类方法，并不是说是父类对象调用了方法。\r\n12.\t方法中创建对象并返回时，应在return中调用autorelease。\r\n13.\t指针调方法时，真正调用方法的是指向的对象，和指针本身无关。如pA = pB后，pA调用的方法就是pB所指对象在调用，和pA原来指向的对象无关。\r\n14.\tOC的多态不一定要基类指针，id类型的通用指针也可以实现多态，在对象类型都一样的情况下，实际上是通过对象本身去实现的。因为所有对象的根类NSObject的第一个实例变量是一个Class类型的结构体指针isa，Class是一个类对象结构体。类其实也是一种对象，称为类对象，在程序运行时一直存在，其中存储了类对象的地址isa、类的大小instance_size、父类superclass、名字name、变量ivars和方法列表methodLists等。类对象调用alloc时，实际是通过malloc类对象中instance_size数量的空间以实例化对象，然后将类对象的地址赋给该对象第一个变量即isa指针。之后在传递消息时，会根据isa的地址找到类对象，在类对象中的methodLists中寻找该方法，如果没有，则根据superclass继续向上寻找。从而实现多态。\r\n15.\tId类型是动态类型，在运行时才能确定对象具体类型。类似A *p = xxx，p是静态类型的，编译期就确定了类型。如果不涉及多态，应使用静态类型。\r\n16.\t在methodLists中寻找方法并不是通过对比字符串，OC在编译时会对同样签名的方法给一个唯一的SEL类型的ID，通过这个ID去寻找方法。即使在不同类中，只要签名相同ID就相同。SEL本身是一个objc_selector结构体的别名。一个方法的SEL类型ID可以通过SEL a = @selector(func) 得到。\r\n17.\tIMP类型是implementation的缩写，实际是一种函数指针类型。通过对象调用methodForSelector传入SEL值，可以获得该方法的指针，从而使用C语言的形式直接调用。这个被指向的方法有两个隐含参数，第一个是self，第二个是SEL，并返回id类型。 (pic)\r\n18.\t由于每次传递消息都需要从isa指针去寻找类对象中的方法进行对比，同一个方法连续使用时影响效率。可以直接先通过获取该方法SEL，通过获取IMP调用。\r\n19.\t动态类型识别的应用：(pic)  \r\n20.\t动态加载 (pic)\r\n21.\t协议即抽象类或接口，@optional是可以实现也可以不实现的，@required（默认）必须实现。协议作为委托时一般都是为了实现异步回调。\r\n22.\tUI事件定义IBAction成员变量和对应属性（记得release），从事件拖动到file’s owner。需要对控件属性改变，则定义输出口，即IBOutlet，将file’s owner拖动到控件。如果是比如导航视图，则不是file’s owner而是当前视图控制器。\r\n23.\t关闭键盘的动作是通过文本控件调用 resignFirstResponder 即放弃第一响应者来实现的。点关闭按钮的事件可以直接在文本控件的事件中找，点屏幕关闭需要把View的类改为UIControl。\r\n24.\tUIAlertView调用show后需要立刻release。\r\n25.\tNSTimer的单位是秒，对象调用invalidate停止计时器事件。\r\n26.\t如果在屏幕旋转时不同视图之间需要有较大差别，则需要作不同的页面，然后每种视图页面实例化一份控件，重写屏幕即将旋转的方法，进行更换。横竖屏切换时需要更换屏幕尺寸，注意状态栏的高度。\r\n27.\tWebView是通过WebKit框架实现的，支持html5不支持flash。\r\n\r\n# Nginx\r\n1.\treload调用后会启动一个新的nginx进程并向原先的master进程发信号，master会加载配置文件，之后启动新的worker进程以接收新的请求，并向老worker进程发信号，老worker进程收到信号后不再接收新请求，会在完成当前进程中任务后退出。\r\n2.\tworker的个数应该和cpu核数相等，更多的worker数，只会导致进程来竞争cpu资源了，从而带来不必要的上下文切换。\r\n3.\t在操作系统中，通过ulimit -n，我们可以得到一个进程所能够打开的fd的最大数，即nofile，因为每个socket连接会占用掉一个fd，所以这也会限制我们进程的最大连接数，当然也会直接影响到我们程序所能支持的最大并发数，当fd用完后，再创建socket时，就会失败。nginx通过设置worker_connectons来设置每个进程支持的最大连接数。如果该值大于nofile，那么实际的最大连接数是nofile，nginx会有警告。nginx在实现时，是通过一个连接池来管理的，每个worker进程都有一个独立的连接池，连接池的大小是worker_connections。这里的连接池里面保存的其实不是真实的连接，它只是一个worker_connections大小的一个ngx_connection_t结构的数组。并且，nginx会通过一个链表free_connections来保存所有的空闲ngx_connection_t，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}